<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module raytracing.abcd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="raytracing.html"><font color="#ffffff">raytracing</font></a>.abcd</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/Users/dccote/GitHub/RayTracing/raytracing/abcd.py">/Users/dccote/GitHub/RayTracing/raytracing/abcd.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="math.html">math</a><br>
<a href="matplotlib.path.html">matplotlib.path</a><br>
</td><td width="25%" valign=top><a href="os.html">os</a><br>
<a href="matplotlib.patches.html">matplotlib.patches</a><br>
</td><td width="25%" valign=top><a href="matplotlib.pyplot.html">matplotlib.pyplot</a><br>
<a href="subprocess.html">subprocess</a><br>
</td><td width="25%" valign=top><a href="sys.html">sys</a><br>
<a href="matplotlib.transforms.html">matplotlib.transforms</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#GaussianBeam">GaussianBeam</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#Matrix">Matrix</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#Aperture">Aperture</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#DielectricInterface">DielectricInterface</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#Lens">Lens</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#ImagingPath">ImagingPath</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#LaserPath">LaserPath</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#Space">Space</a>
</font></dt><dt><font face="helvetica, arial"><a href="raytracing.abcd.html#ThickLens">ThickLens</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#DielectricSlab">DielectricSlab</a>
</font></dt></dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="raytracing.abcd.html#Ray">Ray</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Aperture">class <strong>Aperture</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Aperture">Aperture</a>(diameter,&nbsp;label='')<br>
&nbsp;<br>
An&nbsp;aperture&nbsp;of&nbsp;finite&nbsp;diameter,&nbsp;null&nbsp;thickness.<br>
&nbsp;<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;finite&nbsp;diameter,&nbsp;the&nbsp;ray&nbsp;is&nbsp;blocked.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#Aperture">Aperture</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Aperture-__init__"><strong>__init__</strong></a>(self, diameter, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Aperture-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Currently&nbsp;nothing&nbsp;specific&nbsp;to&nbsp;draw&nbsp;because&nbsp;any<br>
aperture&nbsp;for&nbsp;any&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;drawn&nbsp;with&nbsp;<a href="#Aperture-drawAperture">drawAperture</a>()</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="Aperture-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="Aperture-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="Aperture-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="Aperture-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Aperture-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Aperture-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="Aperture-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="Aperture-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="Aperture-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="Aperture-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="Aperture-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="Aperture-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="Aperture-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="Aperture-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Aperture-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Aperture-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="Aperture-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Aperture-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Aperture-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Aperture-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="Aperture-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="Aperture-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="Aperture-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Aperture-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="Aperture-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="Aperture-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="Aperture-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="Aperture-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="Aperture-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Aperture-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="Aperture-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="Aperture-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="DielectricInterface">class <strong>DielectricInterface</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#DielectricInterface">DielectricInterface</a>(n1,&nbsp;n2,&nbsp;R=inf,&nbsp;diameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;dielectric&nbsp;interface&nbsp;of&nbsp;radius&nbsp;R,&nbsp;with&nbsp;an&nbsp;index&nbsp;n1&nbsp;before&nbsp;and&nbsp;n2<br>
after&nbsp;the&nbsp;interface<br>
&nbsp;<br>
A&nbsp;convex&nbsp;interface&nbsp;from&nbsp;the&nbsp;perspective&nbsp;of&nbsp;the&nbsp;ray&nbsp;has&nbsp;R&nbsp;&gt;&nbsp;0<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#DielectricInterface">DielectricInterface</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="DielectricInterface-__init__"><strong>__init__</strong></a>(self, n1, n2, R=inf, diameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="DielectricInterface-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="DielectricInterface-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="DielectricInterface-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="DielectricInterface-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="DielectricInterface-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;element&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Default&nbsp;is&nbsp;a&nbsp;black&nbsp;box&nbsp;of&nbsp;appropriate&nbsp;length.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="DielectricInterface-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="DielectricInterface-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#DielectricInterface-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="DielectricInterface-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="DielectricInterface-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="DielectricInterface-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="DielectricInterface-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="DielectricInterface-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="DielectricInterface-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="DielectricInterface-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#DielectricInterface-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="DielectricInterface-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="DielectricInterface-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="DielectricSlab">class <strong>DielectricSlab</strong></a>(<a href="raytracing.abcd.html#ThickLens">ThickLens</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#DielectricSlab">DielectricSlab</a>(n,&nbsp;thickness,&nbsp;diameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;slab&nbsp;of&nbsp;dielectric&nbsp;material&nbsp;of&nbsp;index&nbsp;n&nbsp;and&nbsp;length&nbsp;d,&nbsp;with&nbsp;flat&nbsp;faces<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#DielectricSlab">DielectricSlab</a></dd>
<dd><a href="raytracing.abcd.html#ThickLens">ThickLens</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="DielectricSlab-__init__"><strong>__init__</strong></a>(self, n, thickness, diameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;a&nbsp;faint&nbsp;blue&nbsp;box&nbsp;of&nbsp;length&nbsp;L&nbsp;starting&nbsp;at&nbsp;'z'.</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#ThickLens">ThickLens</a>:<br>
<dl><dt><a name="DielectricSlab-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.<br>
The&nbsp;thick&nbsp;lens&nbsp;requires&nbsp;special&nbsp;care&nbsp;because&nbsp;the&nbsp;corners&nbsp;are&nbsp;not<br>
separated&nbsp;by&nbsp;self.<strong>L</strong>:&nbsp;the&nbsp;curvature&nbsp;makes&nbsp;the&nbsp;edges&nbsp;shorter.<br>
We&nbsp;are&nbsp;picky&nbsp;and&nbsp;draw&nbsp;it&nbsp;right.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>List&nbsp;of&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;element&nbsp;as&nbsp;a&nbsp;dictionary:<br>
'z':position<br>
'label':the&nbsp;label&nbsp;to&nbsp;be&nbsp;used.&nbsp;&nbsp;Can&nbsp;include&nbsp;LaTeX&nbsp;math&nbsp;code.</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="DielectricSlab-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="DielectricSlab-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="DielectricSlab-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="DielectricSlab-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="DielectricSlab-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="DielectricSlab-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="DielectricSlab-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#DielectricSlab-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="DielectricSlab-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="DielectricSlab-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="DielectricSlab-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="DielectricSlab-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="DielectricSlab-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="DielectricSlab-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#DielectricSlab-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="DielectricSlab-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="DielectricSlab-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>Element</strong> = <a name="Element">class Matrix</a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Element">Element</a>(A:&nbsp;float&nbsp;=&nbsp;1,&nbsp;B:&nbsp;float&nbsp;=&nbsp;0,&nbsp;C:&nbsp;float&nbsp;=&nbsp;0,&nbsp;D:&nbsp;float&nbsp;=&nbsp;1,&nbsp;physicalLength:&nbsp;float&nbsp;=&nbsp;0,&nbsp;frontVertex=None,&nbsp;backVertex=None,&nbsp;frontIndex=1.0,&nbsp;backIndex=1.0,&nbsp;apertureDiameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;matrix&nbsp;and&nbsp;an&nbsp;optical&nbsp;element&nbsp;that&nbsp;can&nbsp;transform&nbsp;a&nbsp;ray&nbsp;or&nbsp;another<br>
matrix.<br>
&nbsp;<br>
The&nbsp;general&nbsp;properties&nbsp;(A,B,C,D)&nbsp;are&nbsp;defined&nbsp;here.&nbsp;The&nbsp;operator&nbsp;"*"&nbsp;is<br>
overloaded&nbsp;to&nbsp;allow&nbsp;simple&nbsp;statements&nbsp;such&nbsp;as:<br>
&nbsp;<br>
ray2&nbsp;=&nbsp;M1&nbsp;*&nbsp;ray<br>
or<br>
M3&nbsp;=&nbsp;M2&nbsp;*&nbsp;M1<br>
&nbsp;<br>
The&nbsp;physical&nbsp;length&nbsp;is&nbsp;included&nbsp;in&nbsp;the&nbsp;matrix&nbsp;to&nbsp;allow&nbsp;simple&nbsp;management&nbsp;of<br>
the&nbsp;ray&nbsp;tracing.&nbsp;IF&nbsp;two&nbsp;matrices&nbsp;are&nbsp;multiplied,&nbsp;the&nbsp;resulting&nbsp;matrice<br>
will&nbsp;have&nbsp;a&nbsp;physical&nbsp;length&nbsp;that&nbsp;is&nbsp;the&nbsp;sum&nbsp;of&nbsp;both&nbsp;matrices.<br>
&nbsp;<br>
In&nbsp;addition&nbsp;finite&nbsp;apertures&nbsp;are&nbsp;considered:&nbsp;if&nbsp;the&nbsp;apertureDiameter<br>
is&nbsp;not&nbsp;infinite&nbsp;(default),&nbsp;then&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;assumed&nbsp;to&nbsp;limit&nbsp;the<br>
ray&nbsp;height&nbsp;to&nbsp;plus&nbsp;or&nbsp;minus&nbsp;apertureDiameter/2&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back<br>
edge&nbsp;of&nbsp;the&nbsp;element.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Matrix-__init__"><strong>__init__</strong></a>(self, A: float = 1, B: float = 0, C: float = 0, D: float = 1, physicalLength: float = 0, frontVertex=None, backVertex=None, frontIndex=1.0, backIndex=1.0, apertureDiameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Matrix-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="Matrix-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="Matrix-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="Matrix-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Matrix-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="Matrix-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="Matrix-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="Matrix-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;element&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Default&nbsp;is&nbsp;a&nbsp;black&nbsp;box&nbsp;of&nbsp;appropriate&nbsp;length.</tt></dd></dl>

<dl><dt><a name="Matrix-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="Matrix-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="Matrix-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="Matrix-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="Matrix-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="Matrix-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Element-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="Matrix-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Matrix-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="Matrix-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="Matrix-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="Matrix-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Matrix-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="Matrix-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="Matrix-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="Matrix-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="Matrix-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="Matrix-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Element-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="Matrix-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="Matrix-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="GaussianBeam">class <strong>GaussianBeam</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#GaussianBeam">GaussianBeam</a>(w=None,&nbsp;R=inf,&nbsp;n=1.0,&nbsp;wavelength=0.0006328,&nbsp;z=0)<br>
&nbsp;<br>
A&nbsp;gaussian&nbsp;laser&nbsp;beam&nbsp;using&nbsp;the&nbsp;ABCD&nbsp;formalism&nbsp;for&nbsp;propagation<br>
&nbsp;<br>
w&nbsp;is&nbsp;the&nbsp;1/e&nbsp;beam&nbsp;size&nbsp;in&nbsp;electric&nbsp;field.<br>
R&nbsp;is&nbsp;the&nbsp;radius&nbsp;of&nbsp;curvature&nbsp;(positive&nbsp;means&nbsp;diverging)<br>
n&nbsp;is&nbsp;index&nbsp;in&nbsp;which&nbsp;the&nbsp;beam&nbsp;is.&nbsp;Necessary&nbsp;to&nbsp;compute&nbsp;beam&nbsp;size<br>
wavelength&nbsp;is&nbsp;in&nbsp;the&nbsp;same&nbsp;units<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="GaussianBeam-__init__"><strong>__init__</strong></a>(self, w=None, R=inf, n=1.0, wavelength=0.0006328, z=0)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="GaussianBeam-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Ray">Ray</a>())</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>R</strong></dt>
</dl>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>confocalParameter</strong></dt>
</dl>
<dl><dt><strong>rayleighRange</strong></dt>
</dl>
<dl><dt><strong>w</strong></dt>
</dl>
<dl><dt><strong>waist</strong></dt>
</dl>
<dl><dt><strong>waistPosition</strong></dt>
</dl>
<dl><dt><strong>wo</strong></dt>
</dl>
<dl><dt><strong>zo</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>Group</strong> = <a name="Group">class MatrixGroup</a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Group">Group</a>(elements=[],&nbsp;label='')<br>
&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>:&nbsp;A&nbsp;group&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;allowing<br>
the&nbsp;combination&nbsp;of&nbsp;several&nbsp;elements&nbsp;to&nbsp;be&nbsp;treated&nbsp;as&nbsp;a&nbsp;<br>
whole,&nbsp;or&nbsp;treated&nbsp;explicitly&nbsp;as&nbsp;a&nbsp;sequence&nbsp;when&nbsp;needed.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MatrixGroup-ImagingPath"><strong>ImagingPath</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-LaserPath"><strong>LaserPath</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-__init__"><strong>__init__</strong></a>(self, elements=[], label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-append"><strong>append</strong></a>(self, matrix)</dt><dd><tt>Add&nbsp;an&nbsp;element&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;path</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=True)</dt><dd><tt>Draw&nbsp;each&nbsp;element&nbsp;of&nbsp;this&nbsp;group</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.<br>
&nbsp;<br>
AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="MatrixGroup-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;<a href="#ImagingPath">ImagingPath</a>&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;of&nbsp;finite&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="MatrixGroup-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;finite&nbsp;diameter&nbsp;in&nbsp;all&nbsp;elements</tt></dd></dl>

<dl><dt><a name="MatrixGroup-propagate"><strong>propagate</strong></a>(self, inputRay)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#Group-trace">trace</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-propagateMany"><strong>propagateMany</strong></a>(self, inputRays)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#Group-traceMany">traceMany</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-trace"><strong>trace</strong></a>(self, inputRay)</dt><dd><tt>Trace&nbsp;the&nbsp;input&nbsp;ray&nbsp;from&nbsp;first&nbsp;element&nbsp;until&nbsp;after&nbsp;the&nbsp;last&nbsp;element<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;ray&nbsp;trace&nbsp;(i.e.&nbsp;[<a href="#Ray">Ray</a>()])&nbsp;starting&nbsp;with&nbsp;inputRay,&nbsp;followed&nbsp;by&nbsp;the&nbsp;ray&nbsp;after<br>
each&nbsp;element.&nbsp;If&nbsp;an&nbsp;element&nbsp;is&nbsp;composed&nbsp;of&nbsp;sub-elements,&nbsp;the&nbsp;ray&nbsp;will&nbsp;also&nbsp;be<br>
traced&nbsp;in&nbsp;several&nbsp;steps.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;them&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;transfer&nbsp;matrix&nbsp;between&nbsp;front&nbsp;edge&nbsp;and&nbsp;distance=upTo<br>
&nbsp;<br>
If&nbsp;"upTo"&nbsp;falls&nbsp;inside&nbsp;an&nbsp;element&nbsp;of&nbsp;finite&nbsp;length,&nbsp;then&nbsp;<br>
it&nbsp;will&nbsp;request&nbsp;from&nbsp;that&nbsp;element&nbsp;a&nbsp;"partial"&nbsp;transfer&nbsp;matrix<br>
for&nbsp;a&nbsp;fraction&nbsp;of&nbsp;the&nbsp;length.&nbsp;&nbsp;It&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;define&nbsp;such&nbsp;partial&nbsp;transfer&nbsp;matrix&nbsp;when&nbsp;possible.<br>
Quite&nbsp;simply,&nbsp;<a href="#Space">Space</a>()&nbsp;defines&nbsp;a&nbsp;partial&nbsp;matrix&nbsp;as&nbsp;<a href="#Space">Space</a>(d=upTo).</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="MatrixGroup-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="MatrixGroup-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="MatrixGroup-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="MatrixGroup-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="MatrixGroup-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="MatrixGroup-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Group-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="MatrixGroup-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="MatrixGroup-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Group-trace">trace</a>().</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ImagingPath">class <strong>ImagingPath</strong></a>(<a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ImagingPath-ImagingPath">ImagingPath</a>(elements=[],&nbsp;label='')<br>
&nbsp;<br>
<a href="#ImagingPath">ImagingPath</a>:&nbsp;the&nbsp;main&nbsp;class&nbsp;of&nbsp;the&nbsp;module,&nbsp;allowing<br>
the&nbsp;combination&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;be&nbsp;used&nbsp;<br>
as&nbsp;an&nbsp;imaging&nbsp;group&nbsp;with&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;beginning.<br>
&nbsp;<br>
Usage&nbsp;is&nbsp;to&nbsp;create&nbsp;the&nbsp;<a href="#ImagingPath-ImagingPath">ImagingPath</a>(),&nbsp;then&nbsp;<a href="#ImagingPath-append">append</a>()&nbsp;elements<br>
and&nbsp;<a href="#ImagingPath-display">display</a>().&nbsp;You&nbsp;may&nbsp;change&nbsp;objectHeight,&nbsp;fanAngle,&nbsp;fanNumber<br>
and&nbsp;rayNumber.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#ImagingPath">ImagingPath</a></dd>
<dd><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ImagingPath-__init__"><strong>__init__</strong></a>(self, elements=[], label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="ImagingPath-apertureStop"><strong>apertureStop</strong></a>(self)</dt><dd><tt>The&nbsp;aperture&nbsp;in&nbsp;the&nbsp;system&nbsp;that&nbsp;limits&nbsp;the&nbsp;cone&nbsp;of&nbsp;angles<br>
originating&nbsp;from&nbsp;zero&nbsp;height&nbsp;at&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;plane.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;position&nbsp;and&nbsp;diameter&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop<br>
&nbsp;<br>
Strategy:&nbsp;we&nbsp;take&nbsp;a&nbsp;ray&nbsp;height&nbsp;and&nbsp;divide&nbsp;by&nbsp;real&nbsp;aperture<br>
diameter&nbsp;at&nbsp;that&nbsp;position.&nbsp;&nbsp;Some&nbsp;elements&nbsp;may&nbsp;have&nbsp;a&nbsp;finite&nbsp;length<br>
(e.g.,&nbsp;<a href="#Space">Space</a>()&nbsp;or&nbsp;<a href="#ThickLens">ThickLens</a>()),&nbsp;so&nbsp;we&nbsp;always&nbsp;calculate&nbsp;the&nbsp;ratio<br>
before&nbsp;propagating&nbsp;inside&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having&nbsp;propoagated<br>
through&nbsp;the&nbsp;element.&nbsp;The&nbsp;position&nbsp;where&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;the<br>
ratio&nbsp;is&nbsp;maximum&nbsp;is&nbsp;the&nbsp;aperture&nbsp;stop.<br>
&nbsp;<br>
If&nbsp;there&nbsp;are&nbsp;no&nbsp;elements&nbsp;of&nbsp;finite&nbsp;diameter&nbsp;(i.e.&nbsp;all<br>
optical&nbsp;elements&nbsp;are&nbsp;infinite&nbsp;in&nbsp;diameters),&nbsp;then<br>
there&nbsp;is&nbsp;no&nbsp;aperture&nbsp;stop&nbsp;in&nbsp;the&nbsp;system&nbsp;and&nbsp;the&nbsp;size<br>
of&nbsp;the&nbsp;aperture&nbsp;stop&nbsp;is&nbsp;infinite.</tt></dd></dl>

<dl><dt><a name="ImagingPath-axialRays"><strong>axialRays</strong></a>(self, y)</dt><dd><tt>Synonym&nbsp;of&nbsp;marginal&nbsp;rays</tt></dd></dl>

<dl><dt><a name="ImagingPath-chiefRay"><strong>chiefRay</strong></a>(self, y)</dt><dd><tt>Chief&nbsp;ray&nbsp;for&nbsp;a&nbsp;height&nbsp;y&nbsp;(i.e.,&nbsp;the&nbsp;ray&nbsp;that&nbsp;goes<br>
through&nbsp;the&nbsp;center&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop)<br>
&nbsp;<br>
The&nbsp;calculation&nbsp;is&nbsp;simple:&nbsp;obtain&nbsp;the&nbsp;transfer&nbsp;matrix<br>
to&nbsp;the&nbsp;aperture&nbsp;stop,&nbsp;then&nbsp;we&nbsp;know&nbsp;that&nbsp;the&nbsp;input&nbsp;ray<br>
(which&nbsp;we&nbsp;are&nbsp;looking&nbsp;for)&nbsp;will&nbsp;end&nbsp;at&nbsp;y=0&nbsp;at&nbsp;the<br>
aperture&nbsp;stop.</tt></dd></dl>

<dl><dt><a name="ImagingPath-createRayTracePlot"><strong>createRayTracePlot</strong></a>(self, axes, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False)</dt><dd><tt>Create&nbsp;a&nbsp;matplotlib&nbsp;plot&nbsp;to&nbsp;draw&nbsp;the&nbsp;rays&nbsp;and&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
Three&nbsp;optional&nbsp;parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;limitObjectToFieldOfView=False,&nbsp;to&nbsp;use&nbsp;the&nbsp;calculated&nbsp;field&nbsp;of&nbsp;view<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;the&nbsp;objectHeight<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;onlyChiefAndMarginalRays=False,&nbsp;to&nbsp;only&nbsp;show&nbsp;principal&nbsp;rays<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;removeBlockedRaysCompletely=False&nbsp;to&nbsp;remove&nbsp;rays&nbsp;that&nbsp;are&nbsp;blocked.</tt></dd></dl>

<dl><dt><a name="ImagingPath-display"><strong>display</strong></a>(self, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False, comments=None)</dt><dd><tt>Display&nbsp;the&nbsp;optical&nbsp;system&nbsp;and&nbsp;trace&nbsp;the&nbsp;rays.&nbsp;If&nbsp;comments&nbsp;are&nbsp;included<br>
they&nbsp;will&nbsp;be&nbsp;displayed&nbsp;on&nbsp;a&nbsp;graph&nbsp;in&nbsp;the&nbsp;bottom&nbsp;half&nbsp;of&nbsp;the&nbsp;plot.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawEntrancePupil"><strong>drawEntrancePupil</strong></a>(self, z, axes)</dt></dl>

<dl><dt><a name="ImagingPath-drawImages"><strong>drawImages</strong></a>(self, axes)</dt><dd><tt>Draw&nbsp;all&nbsp;images&nbsp;(real&nbsp;and&nbsp;virtual)&nbsp;of&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;defined&nbsp;by&nbsp;<br>
objectPosition,&nbsp;objectHeight</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawObject"><strong>drawObject</strong></a>(self, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;as&nbsp;defined&nbsp;by&nbsp;objectPosition,&nbsp;objectHeight</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawOpticalElements"><strong>drawOpticalElements</strong></a>(self, z, axes)</dt><dd><tt>Deprecated.&nbsp;Use&nbsp;<a href="#ImagingPath-drawAt">drawAt</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawRayTraces"><strong>drawRayTraces</strong></a>(self, axes, onlyChiefAndMarginalRays, removeBlockedRaysCompletely=True)</dt><dd><tt>Draw&nbsp;all&nbsp;ray&nbsp;traces&nbsp;corresponding&nbsp;to&nbsp;either&nbsp;<br>
1.&nbsp;the&nbsp;group&nbsp;of&nbsp;rays&nbsp;defined&nbsp;by&nbsp;the&nbsp;user&nbsp;(fanAngle,&nbsp;fanNumber,&nbsp;rayNumber)&nbsp;<br>
2.&nbsp;the&nbsp;principal&nbsp;rays&nbsp;(chief&nbsp;and&nbsp;marginal)</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawStops"><strong>drawStops</strong></a>(self, z, axes)</dt><dd><tt>AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-entrancePupil"><strong>entrancePupil</strong></a>(self)</dt><dd><tt>The&nbsp;entrance&nbsp;pupil&nbsp;is&nbsp;the&nbsp;image&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop<br>
as&nbsp;seen&nbsp;from&nbsp;the&nbsp;<a href="builtins.html#object">object</a>.&nbsp;To&nbsp;obtain&nbsp;this&nbsp;image,&nbsp;we&nbsp;simply<br>
need&nbsp;to&nbsp;know&nbsp;the&nbsp;tranfer&nbsp;matrix&nbsp;to&nbsp;the&nbsp;aperture&nbsp;stop,<br>
then&nbsp;find&nbsp;the&nbsp;"backward"&nbsp;conjugate,&nbsp;which&nbsp;means&nbsp;finding<br>
the&nbsp;position&nbsp;of&nbsp;the&nbsp;"image"&nbsp;(the&nbsp;entrance&nbsp;pupil)&nbsp;that&nbsp;would&nbsp;<br>
lead&nbsp;to&nbsp;the&nbsp;"<a href="builtins.html#object">object</a>"&nbsp;(aperture&nbsp;stop)&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;transfer<br>
matrix.&nbsp;All&nbsp;the&nbsp;terminology&nbsp;is&nbsp;such&nbsp;that&nbsp;it&nbsp;assumes<br>
the&nbsp;"<a href="builtins.html#object">object</a>"&nbsp;is&nbsp;at&nbsp;the&nbsp;front&nbsp;and&nbsp;the&nbsp;"image"&nbsp;is&nbsp;at&nbsp;the&nbsp;back,<br>
so&nbsp;we&nbsp;need&nbsp;to&nbsp;invert&nbsp;the&nbsp;magnification.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;pupilPosition&nbsp;relative&nbsp;to&nbsp;input&nbsp;reference&nbsp;plane<br>
(positive&nbsp;means&nbsp;to&nbsp;the&nbsp;right)&nbsp;and&nbsp;its&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="ImagingPath-fieldOfView"><strong>fieldOfView</strong></a>(self)</dt><dd><tt>The&nbsp;field&nbsp;of&nbsp;view&nbsp;is&nbsp;the&nbsp;maximum&nbsp;<a href="builtins.html#object">object</a>&nbsp;height<br>
visible&nbsp;until&nbsp;its&nbsp;chief&nbsp;ray&nbsp;is&nbsp;blocked&nbsp;by&nbsp;the&nbsp;field&nbsp;stop<br>
&nbsp;<br>
Strategy:&nbsp;take&nbsp;ray&nbsp;at&nbsp;various&nbsp;heights&nbsp;from&nbsp;<a href="builtins.html#object">object</a>&nbsp;and<br>
aim&nbsp;at&nbsp;center&nbsp;of&nbsp;pupil&nbsp;(chief&nbsp;ray&nbsp;from&nbsp;that&nbsp;point)<br>
until&nbsp;ray&nbsp;is&nbsp;blocked.&nbsp;It&nbsp;is&nbsp;possible&nbsp;to&nbsp;have&nbsp;finite<br>
diameter&nbsp;elements&nbsp;but&nbsp;still&nbsp;an&nbsp;infinite&nbsp;field&nbsp;of&nbsp;view<br>
and&nbsp;therefore&nbsp;no&nbsp;Field&nbsp;stop.</tt></dd></dl>

<dl><dt><a name="ImagingPath-fieldStop"><strong>fieldStop</strong></a>(self)</dt><dd><tt>The&nbsp;field&nbsp;stop&nbsp;is&nbsp;the&nbsp;aperture&nbsp;that&nbsp;limits&nbsp;the&nbsp;image<br>
size&nbsp;(or&nbsp;field&nbsp;of&nbsp;view)<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;position&nbsp;and&nbsp;diameter&nbsp;of&nbsp;the&nbsp;field&nbsp;stop.<br>
&nbsp;<br>
Strategy:&nbsp;We&nbsp;want&nbsp;to&nbsp;find&nbsp;the&nbsp;exact&nbsp;height&nbsp;from&nbsp;the&nbsp;<a href="builtins.html#object">object</a><br>
where&nbsp;it&nbsp;is&nbsp;blocked&nbsp;by&nbsp;an&nbsp;aperture&nbsp;(which&nbsp;will&nbsp;become&nbsp;the<br>
field&nbsp;stop).&nbsp;We&nbsp;look&nbsp;for&nbsp;the&nbsp;point&nbsp;that&nbsp;separates&nbsp;the<br>
"unblocked"&nbsp;ray&nbsp;from&nbsp;the&nbsp;"blocked"&nbsp;ray.<br>
&nbsp;<br>
To&nbsp;do&nbsp;so,&nbsp;we&nbsp;take&nbsp;a&nbsp;ray&nbsp;at&nbsp;various&nbsp;heights&nbsp;starting&nbsp;at&nbsp;y=0<br>
from&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;a&nbsp;finite&nbsp;increment&nbsp;"dy"&nbsp;and&nbsp;aim&nbsp;<br>
at&nbsp;center&nbsp;of&nbsp;pupil&nbsp;(i.e.&nbsp;chief&nbsp;ray&nbsp;from&nbsp;that&nbsp;height)&nbsp;<br>
until&nbsp;ray&nbsp;is&nbsp;blocked.&nbsp;If&nbsp;it&nbsp;is&nbsp;not&nbsp;blocked,&nbsp;increase<br>
dy&nbsp;and&nbsp;increase&nbsp;y&nbsp;by&nbsp;dy.&nbsp;When&nbsp;it&nbsp;is&nbsp;blocked,&nbsp;we&nbsp;turn<br>
around&nbsp;and&nbsp;increase&nbsp;by&nbsp;only&nbsp;half&nbsp;the&nbsp;dy,&nbsp;then&nbsp;we&nbsp;continue<br>
until&nbsp;it&nbsp;is&nbsp;unblocked,&nbsp;turn&nbsp;around,&nbsp;divide&nbsp;dy&nbsp;by&nbsp;2,&nbsp;etc...<br>
This&nbsp;rapidly&nbsp;converges&nbsp;to&nbsp;the&nbsp;position&nbsp;at&nbsp;which&nbsp;the&nbsp;ray<br>
is&nbsp;blocked,&nbsp;which&nbsp;is&nbsp;the&nbsp;field&nbsp;stop&nbsp;half&nbsp;diameter.&nbsp;This<br>
strategy&nbsp;is&nbsp;better&nbsp;than&nbsp;linearly&nbsp;going&nbsp;through&nbsp;<a href="builtins.html#object">object</a>&nbsp;heights<br>
because&nbsp;the&nbsp;precision&nbsp;can&nbsp;be&nbsp;very&nbsp;high&nbsp;without&nbsp;a&nbsp;long&nbsp;calculation<br>
time.<br>
&nbsp;<br>
It&nbsp;is&nbsp;possible&nbsp;to&nbsp;have&nbsp;finite&nbsp;diameter&nbsp;elements&nbsp;but<br>
still&nbsp;an&nbsp;infinite&nbsp;field&nbsp;of&nbsp;view&nbsp;and&nbsp;therefore&nbsp;no&nbsp;Field&nbsp;stop.<br>
In&nbsp;fact,&nbsp;if&nbsp;only&nbsp;a&nbsp;single&nbsp;element&nbsp;has&nbsp;a&nbsp;finite&nbsp;diameter,<br>
there&nbsp;is&nbsp;no&nbsp;field&nbsp;stop&nbsp;(only&nbsp;an&nbsp;aperture&nbsp;stop).&nbsp;The&nbsp;limit<br>
is&nbsp;arbitrarily&nbsp;set&nbsp;to&nbsp;maxHeight.<br>
&nbsp;<br>
If&nbsp;there&nbsp;are&nbsp;no&nbsp;elements&nbsp;of&nbsp;finite&nbsp;diameter&nbsp;(i.e.&nbsp;all<br>
optical&nbsp;elements&nbsp;are&nbsp;infinite&nbsp;in&nbsp;diameters),&nbsp;then&nbsp;there<br>
is&nbsp;no&nbsp;field&nbsp;stop&nbsp;and&nbsp;no&nbsp;aperture&nbsp;stop&nbsp;in&nbsp;the&nbsp;system<br>
and&nbsp;their&nbsp;sizes&nbsp;are&nbsp;infinite.</tt></dd></dl>

<dl><dt><a name="ImagingPath-imageSize"><strong>imageSize</strong></a>(self)</dt><dd><tt>The&nbsp;image&nbsp;size&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;field&nbsp;of&nbsp;view<br>
multiplied&nbsp;by&nbsp;magnification</tt></dd></dl>

<dl><dt><a name="ImagingPath-marginalRays"><strong>marginalRays</strong></a>(self, y=0)</dt><dd><tt>Marginal&nbsp;rays&nbsp;for&nbsp;a&nbsp;height&nbsp;y&nbsp;at&nbsp;<a href="builtins.html#object">object</a><br>
(i.e.,&nbsp;the&nbsp;rays&nbsp;that&nbsp;hit&nbsp;the&nbsp;upper&nbsp;and&nbsp;lower<br>
edges&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop).&nbsp;In&nbsp;general,&nbsp;this&nbsp;could<br>
be&nbsp;any&nbsp;height,&nbsp;not&nbsp;just&nbsp;y=0.&nbsp;However,&nbsp;we&nbsp;usually<br>
only&nbsp;want&nbsp;y=0&nbsp;which&nbsp;is&nbsp;implicitly&nbsp;called<br>
"the&nbsp;marginal&nbsp;ray&nbsp;(of&nbsp;the&nbsp;system)",&nbsp;and&nbsp;both&nbsp;rays<br>
will&nbsp;be&nbsp;symmetrically&nbsp;oriented&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the<br>
optical&nbsp;axis.<br>
&nbsp;<br>
The&nbsp;calculation&nbsp;is&nbsp;simple:&nbsp;obtain&nbsp;the&nbsp;transfer&nbsp;matrix<br>
to&nbsp;the&nbsp;aperture&nbsp;stop,&nbsp;then&nbsp;we&nbsp;know&nbsp;that&nbsp;the&nbsp;input&nbsp;ray<br>
(which&nbsp;we&nbsp;are&nbsp;looking&nbsp;for)&nbsp;will&nbsp;end&nbsp;at&nbsp;y=&nbsp;plus/minus&nbsp;diameter/2&nbsp;at&nbsp;the<br>
aperture&nbsp;stop.&nbsp;We&nbsp;return&nbsp;the&nbsp;largest&nbsp;angle&nbsp;first,&nbsp;for<br>
convenience.</tt></dd></dl>

<dl><dt><a name="ImagingPath-rearrangeRayTraceForPlotting"><strong>rearrangeRayTraceForPlotting</strong></a>(self, rayList, removeBlockedRaysCompletely=True)</dt></dl>

<dl><dt><a name="ImagingPath-save"><strong>save</strong></a>(self, filepath, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False, comments=None)</dt></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>:<br>
<dl><dt><a name="ImagingPath-ImagingPath"><strong>ImagingPath</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-LaserPath"><strong>LaserPath</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-append"><strong>append</strong></a>(self, matrix)</dt><dd><tt>Add&nbsp;an&nbsp;element&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;path</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=True)</dt><dd><tt>Draw&nbsp;each&nbsp;element&nbsp;of&nbsp;this&nbsp;group</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.<br>
&nbsp;<br>
AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;<a href="#ImagingPath">ImagingPath</a>&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;of&nbsp;finite&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;finite&nbsp;diameter&nbsp;in&nbsp;all&nbsp;elements</tt></dd></dl>

<dl><dt><a name="ImagingPath-propagate"><strong>propagate</strong></a>(self, inputRay)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#ImagingPath-trace">trace</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-propagateMany"><strong>propagateMany</strong></a>(self, inputRays)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#ImagingPath-traceMany">traceMany</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-trace"><strong>trace</strong></a>(self, inputRay)</dt><dd><tt>Trace&nbsp;the&nbsp;input&nbsp;ray&nbsp;from&nbsp;first&nbsp;element&nbsp;until&nbsp;after&nbsp;the&nbsp;last&nbsp;element<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;ray&nbsp;trace&nbsp;(i.e.&nbsp;[<a href="#Ray">Ray</a>()])&nbsp;starting&nbsp;with&nbsp;inputRay,&nbsp;followed&nbsp;by&nbsp;the&nbsp;ray&nbsp;after<br>
each&nbsp;element.&nbsp;If&nbsp;an&nbsp;element&nbsp;is&nbsp;composed&nbsp;of&nbsp;sub-elements,&nbsp;the&nbsp;ray&nbsp;will&nbsp;also&nbsp;be<br>
traced&nbsp;in&nbsp;several&nbsp;steps.</tt></dd></dl>

<dl><dt><a name="ImagingPath-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;them&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="ImagingPath-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;transfer&nbsp;matrix&nbsp;between&nbsp;front&nbsp;edge&nbsp;and&nbsp;distance=upTo<br>
&nbsp;<br>
If&nbsp;"upTo"&nbsp;falls&nbsp;inside&nbsp;an&nbsp;element&nbsp;of&nbsp;finite&nbsp;length,&nbsp;then&nbsp;<br>
it&nbsp;will&nbsp;request&nbsp;from&nbsp;that&nbsp;element&nbsp;a&nbsp;"partial"&nbsp;transfer&nbsp;matrix<br>
for&nbsp;a&nbsp;fraction&nbsp;of&nbsp;the&nbsp;length.&nbsp;&nbsp;It&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;define&nbsp;such&nbsp;partial&nbsp;transfer&nbsp;matrix&nbsp;when&nbsp;possible.<br>
Quite&nbsp;simply,&nbsp;<a href="#Space">Space</a>()&nbsp;defines&nbsp;a&nbsp;partial&nbsp;matrix&nbsp;as&nbsp;<a href="#Space">Space</a>(d=upTo).</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="ImagingPath-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="ImagingPath-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="ImagingPath-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="ImagingPath-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ImagingPath-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="ImagingPath-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#ImagingPath-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ImagingPath-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="ImagingPath-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="ImagingPath-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="ImagingPath-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="ImagingPath-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="ImagingPath-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#ImagingPath-trace">trace</a>().</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LaserPath">class <strong>LaserPath</strong></a>(<a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#LaserPath-LaserPath">LaserPath</a>(elements=[],&nbsp;label='')<br>
&nbsp;<br>
<a href="#LaserPath">LaserPath</a>:&nbsp;the&nbsp;main&nbsp;class&nbsp;of&nbsp;the&nbsp;module&nbsp;for&nbsp;coherent<br>
laser&nbsp;beams:&nbsp;it&nbsp;is&nbsp;the&nbsp;combination&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<a href="#MatrixGroup">MatrixGroup</a>()<br>
to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;laser&nbsp;path&nbsp;with&nbsp;a&nbsp;laser&nbsp;beam&nbsp;(<a href="#GaussianBeam">GaussianBeam</a>)<br>
at&nbsp;the&nbsp;entrance.<br>
&nbsp;<br>
Usage&nbsp;is&nbsp;to&nbsp;create&nbsp;the&nbsp;<a href="#LaserPath-LaserPath">LaserPath</a>(),&nbsp;then&nbsp;<a href="#LaserPath-append">append</a>()&nbsp;elements<br>
and&nbsp;<a href="#LaserPath-display">display</a>().&nbsp;You&nbsp;may&nbsp;change&nbsp;the&nbsp;inputBeam&nbsp;to&nbsp;any&nbsp;<a href="#GaussianBeam">GaussianBeam</a>(),<br>
or&nbsp;provide&nbsp;one&nbsp;to&nbsp;<a href="#LaserPath-display">display</a>(beam=<a href="#GaussianBeam">GaussianBeam</a>())<br>
&nbsp;<br>
Gaussian&nbsp;laser&nbsp;beams&nbsp;are&nbsp;not&nbsp;"blocked"&nbsp;by&nbsp;aperture.&nbsp;The&nbsp;formalism<br>
does&nbsp;not&nbsp;explicitly&nbsp;allow&nbsp;that.&nbsp;&nbsp;However,&nbsp;if&nbsp;it&nbsp;appears&nbsp;that&nbsp;a&nbsp;<br>
<a href="#GaussianBeam">GaussianBeam</a>()&nbsp;would&nbsp;be&nbsp;clipped&nbsp;by&nbsp;&nbsp;finite&nbsp;aperture,&nbsp;a&nbsp;property&nbsp;<br>
is&nbsp;set&nbsp;to&nbsp;indicate&nbsp;it,&nbsp;but&nbsp;it&nbsp;will&nbsp;propagate&nbsp;nevertheless<br>
and&nbsp;without&nbsp;diffraction&nbsp;due&nbsp;to&nbsp;that&nbsp;aperture.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#LaserPath">LaserPath</a></dd>
<dd><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LaserPath-__init__"><strong>__init__</strong></a>(self, elements=[], label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="LaserPath-createBeamTracePlot"><strong>createBeamTracePlot</strong></a>(self, axes, inputBeam)</dt><dd><tt>Create&nbsp;a&nbsp;matplotlib&nbsp;plot&nbsp;to&nbsp;draw&nbsp;the&nbsp;laser&nbsp;beam&nbsp;and&nbsp;the&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="LaserPath-display"><strong>display</strong></a>(self, inputBeam=None, comments=None)</dt><dd><tt>Display&nbsp;the&nbsp;optical&nbsp;system&nbsp;and&nbsp;trace&nbsp;the&nbsp;laser&nbsp;beam.&nbsp;<br>
If&nbsp;comments&nbsp;are&nbsp;included&nbsp;they&nbsp;will&nbsp;be&nbsp;displayed&nbsp;on&nbsp;a<br>
graph&nbsp;in&nbsp;the&nbsp;bottom&nbsp;half&nbsp;of&nbsp;the&nbsp;plot.</tt></dd></dl>

<dl><dt><a name="LaserPath-drawBeamTrace"><strong>drawBeamTrace</strong></a>(self, axes, beam)</dt><dd><tt>Draw&nbsp;beam&nbsp;trace&nbsp;corresponding&nbsp;to&nbsp;input&nbsp;beam&nbsp;<br>
Because&nbsp;the&nbsp;laser&nbsp;beam&nbsp;diffracts&nbsp;through&nbsp;space,&nbsp;we&nbsp;cannot<br>
simply&nbsp;propagate&nbsp;the&nbsp;beam&nbsp;over&nbsp;large&nbsp;distances&nbsp;and&nbsp;trace&nbsp;it<br>
(as&nbsp;opposed&nbsp;to&nbsp;rays,&nbsp;where&nbsp;we&nbsp;can).&nbsp;We&nbsp;must&nbsp;split&nbsp;<a href="#Space">Space</a>()&nbsp;<br>
elements&nbsp;into&nbsp;sub&nbsp;elements&nbsp;to&nbsp;watch&nbsp;the&nbsp;beam&nbsp;size&nbsp;expand.<br>
&nbsp;<br>
We&nbsp;arbitrarily&nbsp;split&nbsp;<a href="#Space">Space</a>()&nbsp;elements&nbsp;into&nbsp;100&nbsp;sub&nbsp;elements<br>
before&nbsp;plotting.</tt></dd></dl>

<dl><dt><a name="LaserPath-drawWaists"><strong>drawWaists</strong></a>(self, axes, beam)</dt><dd><tt>Draws&nbsp;the&nbsp;expected&nbsp;waist&nbsp;(i.e.&nbsp;the&nbsp;focal&nbsp;spot&nbsp;or&nbsp;the&nbsp;spot&nbsp;where&nbsp;the<br>
size&nbsp;is&nbsp;minimum)&nbsp;for&nbsp;all&nbsp;positions&nbsp;of&nbsp;the&nbsp;beam.&nbsp;This&nbsp;will&nbsp;show&nbsp;"waists"&nbsp;that<br>
are&nbsp;virtual&nbsp;if&nbsp;there&nbsp;is&nbsp;an&nbsp;additional&nbsp;lens&nbsp;between&nbsp;the&nbsp;beam&nbsp;and&nbsp;the&nbsp;expceted<br>
waist.<br>
&nbsp;<br>
It&nbsp;is&nbsp;easy&nbsp;to&nbsp;obtain&nbsp;the&nbsp;waist&nbsp;position&nbsp;from&nbsp;the&nbsp;complex&nbsp;radius&nbsp;of&nbsp;curvature<br>
because&nbsp;it&nbsp;is&nbsp;the&nbsp;position&nbsp;where&nbsp;the&nbsp;complex&nbsp;radius&nbsp;is&nbsp;imaginary.&nbsp;The&nbsp;position<br>
returned&nbsp;is&nbsp;relative&nbsp;to&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;beam,&nbsp;which&nbsp;is&nbsp;why&nbsp;we&nbsp;add&nbsp;the&nbsp;actual<br>
position&nbsp;of&nbsp;the&nbsp;beam&nbsp;to&nbsp;the&nbsp;relative&nbsp;position.</tt></dd></dl>

<dl><dt><a name="LaserPath-rearrangeBeamTraceForPlotting"><strong>rearrangeBeamTraceForPlotting</strong></a>(self, rayList)</dt></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>:<br>
<dl><dt><a name="LaserPath-ImagingPath"><strong>ImagingPath</strong></a>(self)</dt></dl>

<dl><dt><a name="LaserPath-LaserPath"><strong>LaserPath</strong></a>(self)</dt></dl>

<dl><dt><a name="LaserPath-append"><strong>append</strong></a>(self, matrix)</dt><dd><tt>Add&nbsp;an&nbsp;element&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;path</tt></dd></dl>

<dl><dt><a name="LaserPath-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=True)</dt><dd><tt>Draw&nbsp;each&nbsp;element&nbsp;of&nbsp;this&nbsp;group</tt></dd></dl>

<dl><dt><a name="LaserPath-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.<br>
&nbsp;<br>
AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="LaserPath-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;<a href="#ImagingPath">ImagingPath</a>&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;of&nbsp;finite&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="LaserPath-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;finite&nbsp;diameter&nbsp;in&nbsp;all&nbsp;elements</tt></dd></dl>

<dl><dt><a name="LaserPath-propagate"><strong>propagate</strong></a>(self, inputRay)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#LaserPath-trace">trace</a>()</tt></dd></dl>

<dl><dt><a name="LaserPath-propagateMany"><strong>propagateMany</strong></a>(self, inputRays)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#LaserPath-traceMany">traceMany</a>()</tt></dd></dl>

<dl><dt><a name="LaserPath-trace"><strong>trace</strong></a>(self, inputRay)</dt><dd><tt>Trace&nbsp;the&nbsp;input&nbsp;ray&nbsp;from&nbsp;first&nbsp;element&nbsp;until&nbsp;after&nbsp;the&nbsp;last&nbsp;element<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;ray&nbsp;trace&nbsp;(i.e.&nbsp;[<a href="#Ray">Ray</a>()])&nbsp;starting&nbsp;with&nbsp;inputRay,&nbsp;followed&nbsp;by&nbsp;the&nbsp;ray&nbsp;after<br>
each&nbsp;element.&nbsp;If&nbsp;an&nbsp;element&nbsp;is&nbsp;composed&nbsp;of&nbsp;sub-elements,&nbsp;the&nbsp;ray&nbsp;will&nbsp;also&nbsp;be<br>
traced&nbsp;in&nbsp;several&nbsp;steps.</tt></dd></dl>

<dl><dt><a name="LaserPath-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;them&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="LaserPath-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;transfer&nbsp;matrix&nbsp;between&nbsp;front&nbsp;edge&nbsp;and&nbsp;distance=upTo<br>
&nbsp;<br>
If&nbsp;"upTo"&nbsp;falls&nbsp;inside&nbsp;an&nbsp;element&nbsp;of&nbsp;finite&nbsp;length,&nbsp;then&nbsp;<br>
it&nbsp;will&nbsp;request&nbsp;from&nbsp;that&nbsp;element&nbsp;a&nbsp;"partial"&nbsp;transfer&nbsp;matrix<br>
for&nbsp;a&nbsp;fraction&nbsp;of&nbsp;the&nbsp;length.&nbsp;&nbsp;It&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;define&nbsp;such&nbsp;partial&nbsp;transfer&nbsp;matrix&nbsp;when&nbsp;possible.<br>
Quite&nbsp;simply,&nbsp;<a href="#Space">Space</a>()&nbsp;defines&nbsp;a&nbsp;partial&nbsp;matrix&nbsp;as&nbsp;<a href="#Space">Space</a>(d=upTo).</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="LaserPath-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="LaserPath-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="LaserPath-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="LaserPath-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="LaserPath-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="LaserPath-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="LaserPath-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="LaserPath-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="LaserPath-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="LaserPath-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="LaserPath-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="LaserPath-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="LaserPath-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#LaserPath-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="LaserPath-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="LaserPath-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="LaserPath-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="LaserPath-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="LaserPath-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="LaserPath-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="LaserPath-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="LaserPath-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="LaserPath-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="LaserPath-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#LaserPath-trace">trace</a>().</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Lens">class <strong>Lens</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Lens">Lens</a>(f,&nbsp;diameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;thin&nbsp;lens&nbsp;of&nbsp;focal&nbsp;f,&nbsp;null&nbsp;thickness&nbsp;and&nbsp;infinite&nbsp;or&nbsp;finite&nbsp;diameter<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#Lens">Lens</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Lens-__init__"><strong>__init__</strong></a>(self, f, diameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Lens-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;a&nbsp;thin&nbsp;lens&nbsp;at&nbsp;z</tt></dd></dl>

<dl><dt><a name="Lens-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>List&nbsp;of&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;element&nbsp;as&nbsp;a&nbsp;dictionary:<br>
'z':position<br>
'label':the&nbsp;label&nbsp;to&nbsp;be&nbsp;used.&nbsp;&nbsp;Can&nbsp;include&nbsp;LaTeX&nbsp;math&nbsp;code.</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="Lens-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="Lens-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="Lens-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="Lens-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Lens-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Lens-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="Lens-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="Lens-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="Lens-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="Lens-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="Lens-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="Lens-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="Lens-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="Lens-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Lens-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Lens-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="Lens-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Lens-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Lens-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Lens-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="Lens-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="Lens-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="Lens-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Lens-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="Lens-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="Lens-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="Lens-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="Lens-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Lens-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="Lens-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="Lens-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Matrix">class <strong>Matrix</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Matrix">Matrix</a>(A:&nbsp;float&nbsp;=&nbsp;1,&nbsp;B:&nbsp;float&nbsp;=&nbsp;0,&nbsp;C:&nbsp;float&nbsp;=&nbsp;0,&nbsp;D:&nbsp;float&nbsp;=&nbsp;1,&nbsp;physicalLength:&nbsp;float&nbsp;=&nbsp;0,&nbsp;frontVertex=None,&nbsp;backVertex=None,&nbsp;frontIndex=1.0,&nbsp;backIndex=1.0,&nbsp;apertureDiameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;matrix&nbsp;and&nbsp;an&nbsp;optical&nbsp;element&nbsp;that&nbsp;can&nbsp;transform&nbsp;a&nbsp;ray&nbsp;or&nbsp;another<br>
matrix.<br>
&nbsp;<br>
The&nbsp;general&nbsp;properties&nbsp;(A,B,C,D)&nbsp;are&nbsp;defined&nbsp;here.&nbsp;The&nbsp;operator&nbsp;"*"&nbsp;is<br>
overloaded&nbsp;to&nbsp;allow&nbsp;simple&nbsp;statements&nbsp;such&nbsp;as:<br>
&nbsp;<br>
ray2&nbsp;=&nbsp;M1&nbsp;*&nbsp;ray<br>
or<br>
M3&nbsp;=&nbsp;M2&nbsp;*&nbsp;M1<br>
&nbsp;<br>
The&nbsp;physical&nbsp;length&nbsp;is&nbsp;included&nbsp;in&nbsp;the&nbsp;matrix&nbsp;to&nbsp;allow&nbsp;simple&nbsp;management&nbsp;of<br>
the&nbsp;ray&nbsp;tracing.&nbsp;IF&nbsp;two&nbsp;matrices&nbsp;are&nbsp;multiplied,&nbsp;the&nbsp;resulting&nbsp;matrice<br>
will&nbsp;have&nbsp;a&nbsp;physical&nbsp;length&nbsp;that&nbsp;is&nbsp;the&nbsp;sum&nbsp;of&nbsp;both&nbsp;matrices.<br>
&nbsp;<br>
In&nbsp;addition&nbsp;finite&nbsp;apertures&nbsp;are&nbsp;considered:&nbsp;if&nbsp;the&nbsp;apertureDiameter<br>
is&nbsp;not&nbsp;infinite&nbsp;(default),&nbsp;then&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;assumed&nbsp;to&nbsp;limit&nbsp;the<br>
ray&nbsp;height&nbsp;to&nbsp;plus&nbsp;or&nbsp;minus&nbsp;apertureDiameter/2&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back<br>
edge&nbsp;of&nbsp;the&nbsp;element.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Matrix-__init__"><strong>__init__</strong></a>(self, A: float = 1, B: float = 0, C: float = 0, D: float = 1, physicalLength: float = 0, frontVertex=None, backVertex=None, frontIndex=1.0, backIndex=1.0, apertureDiameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Matrix-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="Matrix-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="Matrix-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="Matrix-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Matrix-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="Matrix-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="Matrix-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="Matrix-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;element&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Default&nbsp;is&nbsp;a&nbsp;black&nbsp;box&nbsp;of&nbsp;appropriate&nbsp;length.</tt></dd></dl>

<dl><dt><a name="Matrix-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="Matrix-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="Matrix-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="Matrix-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="Matrix-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="Matrix-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Matrix-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="Matrix-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Matrix-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Matrix-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="Matrix-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="Matrix-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="Matrix-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Matrix-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="Matrix-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="Matrix-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="Matrix-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="Matrix-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="Matrix-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Matrix-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="Matrix-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="Matrix-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MatrixGroup">class <strong>MatrixGroup</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#MatrixGroup">MatrixGroup</a>(elements=[],&nbsp;label='')<br>
&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>:&nbsp;A&nbsp;group&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;allowing<br>
the&nbsp;combination&nbsp;of&nbsp;several&nbsp;elements&nbsp;to&nbsp;be&nbsp;treated&nbsp;as&nbsp;a&nbsp;<br>
whole,&nbsp;or&nbsp;treated&nbsp;explicitly&nbsp;as&nbsp;a&nbsp;sequence&nbsp;when&nbsp;needed.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MatrixGroup-ImagingPath"><strong>ImagingPath</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-LaserPath"><strong>LaserPath</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-__init__"><strong>__init__</strong></a>(self, elements=[], label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-append"><strong>append</strong></a>(self, matrix)</dt><dd><tt>Add&nbsp;an&nbsp;element&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;path</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=True)</dt><dd><tt>Draw&nbsp;each&nbsp;element&nbsp;of&nbsp;this&nbsp;group</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.<br>
&nbsp;<br>
AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="MatrixGroup-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;<a href="#ImagingPath">ImagingPath</a>&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;of&nbsp;finite&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="MatrixGroup-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;finite&nbsp;diameter&nbsp;in&nbsp;all&nbsp;elements</tt></dd></dl>

<dl><dt><a name="MatrixGroup-propagate"><strong>propagate</strong></a>(self, inputRay)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#MatrixGroup-trace">trace</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-propagateMany"><strong>propagateMany</strong></a>(self, inputRays)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#MatrixGroup-traceMany">traceMany</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-trace"><strong>trace</strong></a>(self, inputRay)</dt><dd><tt>Trace&nbsp;the&nbsp;input&nbsp;ray&nbsp;from&nbsp;first&nbsp;element&nbsp;until&nbsp;after&nbsp;the&nbsp;last&nbsp;element<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;ray&nbsp;trace&nbsp;(i.e.&nbsp;[<a href="#Ray">Ray</a>()])&nbsp;starting&nbsp;with&nbsp;inputRay,&nbsp;followed&nbsp;by&nbsp;the&nbsp;ray&nbsp;after<br>
each&nbsp;element.&nbsp;If&nbsp;an&nbsp;element&nbsp;is&nbsp;composed&nbsp;of&nbsp;sub-elements,&nbsp;the&nbsp;ray&nbsp;will&nbsp;also&nbsp;be<br>
traced&nbsp;in&nbsp;several&nbsp;steps.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;them&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;transfer&nbsp;matrix&nbsp;between&nbsp;front&nbsp;edge&nbsp;and&nbsp;distance=upTo<br>
&nbsp;<br>
If&nbsp;"upTo"&nbsp;falls&nbsp;inside&nbsp;an&nbsp;element&nbsp;of&nbsp;finite&nbsp;length,&nbsp;then&nbsp;<br>
it&nbsp;will&nbsp;request&nbsp;from&nbsp;that&nbsp;element&nbsp;a&nbsp;"partial"&nbsp;transfer&nbsp;matrix<br>
for&nbsp;a&nbsp;fraction&nbsp;of&nbsp;the&nbsp;length.&nbsp;&nbsp;It&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;define&nbsp;such&nbsp;partial&nbsp;transfer&nbsp;matrix&nbsp;when&nbsp;possible.<br>
Quite&nbsp;simply,&nbsp;<a href="#Space">Space</a>()&nbsp;defines&nbsp;a&nbsp;partial&nbsp;matrix&nbsp;as&nbsp;<a href="#Space">Space</a>(d=upTo).</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="MatrixGroup-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="MatrixGroup-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="MatrixGroup-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="MatrixGroup-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="MatrixGroup-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="MatrixGroup-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="MatrixGroup-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#MatrixGroup-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="MatrixGroup-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="MatrixGroup-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="MatrixGroup-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="MatrixGroup-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="MatrixGroup-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#MatrixGroup-trace">trace</a>().</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>OpticalPath</strong> = <a name="OpticalPath">class ImagingPath</a>(<a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#OpticalPath">OpticalPath</a>(elements=[],&nbsp;label='')<br>
&nbsp;<br>
<a href="#ImagingPath">ImagingPath</a>:&nbsp;the&nbsp;main&nbsp;class&nbsp;of&nbsp;the&nbsp;module,&nbsp;allowing<br>
the&nbsp;combination&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;be&nbsp;used&nbsp;<br>
as&nbsp;an&nbsp;imaging&nbsp;group&nbsp;with&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;beginning.<br>
&nbsp;<br>
Usage&nbsp;is&nbsp;to&nbsp;create&nbsp;the&nbsp;<a href="#OpticalPath-ImagingPath">ImagingPath</a>(),&nbsp;then&nbsp;<a href="#OpticalPath-append">append</a>()&nbsp;elements<br>
and&nbsp;<a href="#OpticalPath-display">display</a>().&nbsp;You&nbsp;may&nbsp;change&nbsp;objectHeight,&nbsp;fanAngle,&nbsp;fanNumber<br>
and&nbsp;rayNumber.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#ImagingPath">ImagingPath</a></dd>
<dd><a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ImagingPath-__init__"><strong>__init__</strong></a>(self, elements=[], label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="ImagingPath-apertureStop"><strong>apertureStop</strong></a>(self)</dt><dd><tt>The&nbsp;aperture&nbsp;in&nbsp;the&nbsp;system&nbsp;that&nbsp;limits&nbsp;the&nbsp;cone&nbsp;of&nbsp;angles<br>
originating&nbsp;from&nbsp;zero&nbsp;height&nbsp;at&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;plane.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;position&nbsp;and&nbsp;diameter&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop<br>
&nbsp;<br>
Strategy:&nbsp;we&nbsp;take&nbsp;a&nbsp;ray&nbsp;height&nbsp;and&nbsp;divide&nbsp;by&nbsp;real&nbsp;aperture<br>
diameter&nbsp;at&nbsp;that&nbsp;position.&nbsp;&nbsp;Some&nbsp;elements&nbsp;may&nbsp;have&nbsp;a&nbsp;finite&nbsp;length<br>
(e.g.,&nbsp;<a href="#Space">Space</a>()&nbsp;or&nbsp;<a href="#ThickLens">ThickLens</a>()),&nbsp;so&nbsp;we&nbsp;always&nbsp;calculate&nbsp;the&nbsp;ratio<br>
before&nbsp;propagating&nbsp;inside&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having&nbsp;propoagated<br>
through&nbsp;the&nbsp;element.&nbsp;The&nbsp;position&nbsp;where&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;the<br>
ratio&nbsp;is&nbsp;maximum&nbsp;is&nbsp;the&nbsp;aperture&nbsp;stop.<br>
&nbsp;<br>
If&nbsp;there&nbsp;are&nbsp;no&nbsp;elements&nbsp;of&nbsp;finite&nbsp;diameter&nbsp;(i.e.&nbsp;all<br>
optical&nbsp;elements&nbsp;are&nbsp;infinite&nbsp;in&nbsp;diameters),&nbsp;then<br>
there&nbsp;is&nbsp;no&nbsp;aperture&nbsp;stop&nbsp;in&nbsp;the&nbsp;system&nbsp;and&nbsp;the&nbsp;size<br>
of&nbsp;the&nbsp;aperture&nbsp;stop&nbsp;is&nbsp;infinite.</tt></dd></dl>

<dl><dt><a name="ImagingPath-axialRays"><strong>axialRays</strong></a>(self, y)</dt><dd><tt>Synonym&nbsp;of&nbsp;marginal&nbsp;rays</tt></dd></dl>

<dl><dt><a name="ImagingPath-chiefRay"><strong>chiefRay</strong></a>(self, y)</dt><dd><tt>Chief&nbsp;ray&nbsp;for&nbsp;a&nbsp;height&nbsp;y&nbsp;(i.e.,&nbsp;the&nbsp;ray&nbsp;that&nbsp;goes<br>
through&nbsp;the&nbsp;center&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop)<br>
&nbsp;<br>
The&nbsp;calculation&nbsp;is&nbsp;simple:&nbsp;obtain&nbsp;the&nbsp;transfer&nbsp;matrix<br>
to&nbsp;the&nbsp;aperture&nbsp;stop,&nbsp;then&nbsp;we&nbsp;know&nbsp;that&nbsp;the&nbsp;input&nbsp;ray<br>
(which&nbsp;we&nbsp;are&nbsp;looking&nbsp;for)&nbsp;will&nbsp;end&nbsp;at&nbsp;y=0&nbsp;at&nbsp;the<br>
aperture&nbsp;stop.</tt></dd></dl>

<dl><dt><a name="ImagingPath-createRayTracePlot"><strong>createRayTracePlot</strong></a>(self, axes, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False)</dt><dd><tt>Create&nbsp;a&nbsp;matplotlib&nbsp;plot&nbsp;to&nbsp;draw&nbsp;the&nbsp;rays&nbsp;and&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
Three&nbsp;optional&nbsp;parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;limitObjectToFieldOfView=False,&nbsp;to&nbsp;use&nbsp;the&nbsp;calculated&nbsp;field&nbsp;of&nbsp;view<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;the&nbsp;objectHeight<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;onlyChiefAndMarginalRays=False,&nbsp;to&nbsp;only&nbsp;show&nbsp;principal&nbsp;rays<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;removeBlockedRaysCompletely=False&nbsp;to&nbsp;remove&nbsp;rays&nbsp;that&nbsp;are&nbsp;blocked.</tt></dd></dl>

<dl><dt><a name="ImagingPath-display"><strong>display</strong></a>(self, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False, comments=None)</dt><dd><tt>Display&nbsp;the&nbsp;optical&nbsp;system&nbsp;and&nbsp;trace&nbsp;the&nbsp;rays.&nbsp;If&nbsp;comments&nbsp;are&nbsp;included<br>
they&nbsp;will&nbsp;be&nbsp;displayed&nbsp;on&nbsp;a&nbsp;graph&nbsp;in&nbsp;the&nbsp;bottom&nbsp;half&nbsp;of&nbsp;the&nbsp;plot.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawEntrancePupil"><strong>drawEntrancePupil</strong></a>(self, z, axes)</dt></dl>

<dl><dt><a name="ImagingPath-drawImages"><strong>drawImages</strong></a>(self, axes)</dt><dd><tt>Draw&nbsp;all&nbsp;images&nbsp;(real&nbsp;and&nbsp;virtual)&nbsp;of&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;defined&nbsp;by&nbsp;<br>
objectPosition,&nbsp;objectHeight</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawObject"><strong>drawObject</strong></a>(self, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;as&nbsp;defined&nbsp;by&nbsp;objectPosition,&nbsp;objectHeight</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawOpticalElements"><strong>drawOpticalElements</strong></a>(self, z, axes)</dt><dd><tt>Deprecated.&nbsp;Use&nbsp;<a href="#OpticalPath-drawAt">drawAt</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawRayTraces"><strong>drawRayTraces</strong></a>(self, axes, onlyChiefAndMarginalRays, removeBlockedRaysCompletely=True)</dt><dd><tt>Draw&nbsp;all&nbsp;ray&nbsp;traces&nbsp;corresponding&nbsp;to&nbsp;either&nbsp;<br>
1.&nbsp;the&nbsp;group&nbsp;of&nbsp;rays&nbsp;defined&nbsp;by&nbsp;the&nbsp;user&nbsp;(fanAngle,&nbsp;fanNumber,&nbsp;rayNumber)&nbsp;<br>
2.&nbsp;the&nbsp;principal&nbsp;rays&nbsp;(chief&nbsp;and&nbsp;marginal)</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawStops"><strong>drawStops</strong></a>(self, z, axes)</dt><dd><tt>AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-entrancePupil"><strong>entrancePupil</strong></a>(self)</dt><dd><tt>The&nbsp;entrance&nbsp;pupil&nbsp;is&nbsp;the&nbsp;image&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop<br>
as&nbsp;seen&nbsp;from&nbsp;the&nbsp;<a href="builtins.html#object">object</a>.&nbsp;To&nbsp;obtain&nbsp;this&nbsp;image,&nbsp;we&nbsp;simply<br>
need&nbsp;to&nbsp;know&nbsp;the&nbsp;tranfer&nbsp;matrix&nbsp;to&nbsp;the&nbsp;aperture&nbsp;stop,<br>
then&nbsp;find&nbsp;the&nbsp;"backward"&nbsp;conjugate,&nbsp;which&nbsp;means&nbsp;finding<br>
the&nbsp;position&nbsp;of&nbsp;the&nbsp;"image"&nbsp;(the&nbsp;entrance&nbsp;pupil)&nbsp;that&nbsp;would&nbsp;<br>
lead&nbsp;to&nbsp;the&nbsp;"<a href="builtins.html#object">object</a>"&nbsp;(aperture&nbsp;stop)&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;transfer<br>
matrix.&nbsp;All&nbsp;the&nbsp;terminology&nbsp;is&nbsp;such&nbsp;that&nbsp;it&nbsp;assumes<br>
the&nbsp;"<a href="builtins.html#object">object</a>"&nbsp;is&nbsp;at&nbsp;the&nbsp;front&nbsp;and&nbsp;the&nbsp;"image"&nbsp;is&nbsp;at&nbsp;the&nbsp;back,<br>
so&nbsp;we&nbsp;need&nbsp;to&nbsp;invert&nbsp;the&nbsp;magnification.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;pupilPosition&nbsp;relative&nbsp;to&nbsp;input&nbsp;reference&nbsp;plane<br>
(positive&nbsp;means&nbsp;to&nbsp;the&nbsp;right)&nbsp;and&nbsp;its&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="ImagingPath-fieldOfView"><strong>fieldOfView</strong></a>(self)</dt><dd><tt>The&nbsp;field&nbsp;of&nbsp;view&nbsp;is&nbsp;the&nbsp;maximum&nbsp;<a href="builtins.html#object">object</a>&nbsp;height<br>
visible&nbsp;until&nbsp;its&nbsp;chief&nbsp;ray&nbsp;is&nbsp;blocked&nbsp;by&nbsp;the&nbsp;field&nbsp;stop<br>
&nbsp;<br>
Strategy:&nbsp;take&nbsp;ray&nbsp;at&nbsp;various&nbsp;heights&nbsp;from&nbsp;<a href="builtins.html#object">object</a>&nbsp;and<br>
aim&nbsp;at&nbsp;center&nbsp;of&nbsp;pupil&nbsp;(chief&nbsp;ray&nbsp;from&nbsp;that&nbsp;point)<br>
until&nbsp;ray&nbsp;is&nbsp;blocked.&nbsp;It&nbsp;is&nbsp;possible&nbsp;to&nbsp;have&nbsp;finite<br>
diameter&nbsp;elements&nbsp;but&nbsp;still&nbsp;an&nbsp;infinite&nbsp;field&nbsp;of&nbsp;view<br>
and&nbsp;therefore&nbsp;no&nbsp;Field&nbsp;stop.</tt></dd></dl>

<dl><dt><a name="ImagingPath-fieldStop"><strong>fieldStop</strong></a>(self)</dt><dd><tt>The&nbsp;field&nbsp;stop&nbsp;is&nbsp;the&nbsp;aperture&nbsp;that&nbsp;limits&nbsp;the&nbsp;image<br>
size&nbsp;(or&nbsp;field&nbsp;of&nbsp;view)<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;position&nbsp;and&nbsp;diameter&nbsp;of&nbsp;the&nbsp;field&nbsp;stop.<br>
&nbsp;<br>
Strategy:&nbsp;We&nbsp;want&nbsp;to&nbsp;find&nbsp;the&nbsp;exact&nbsp;height&nbsp;from&nbsp;the&nbsp;<a href="builtins.html#object">object</a><br>
where&nbsp;it&nbsp;is&nbsp;blocked&nbsp;by&nbsp;an&nbsp;aperture&nbsp;(which&nbsp;will&nbsp;become&nbsp;the<br>
field&nbsp;stop).&nbsp;We&nbsp;look&nbsp;for&nbsp;the&nbsp;point&nbsp;that&nbsp;separates&nbsp;the<br>
"unblocked"&nbsp;ray&nbsp;from&nbsp;the&nbsp;"blocked"&nbsp;ray.<br>
&nbsp;<br>
To&nbsp;do&nbsp;so,&nbsp;we&nbsp;take&nbsp;a&nbsp;ray&nbsp;at&nbsp;various&nbsp;heights&nbsp;starting&nbsp;at&nbsp;y=0<br>
from&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;a&nbsp;finite&nbsp;increment&nbsp;"dy"&nbsp;and&nbsp;aim&nbsp;<br>
at&nbsp;center&nbsp;of&nbsp;pupil&nbsp;(i.e.&nbsp;chief&nbsp;ray&nbsp;from&nbsp;that&nbsp;height)&nbsp;<br>
until&nbsp;ray&nbsp;is&nbsp;blocked.&nbsp;If&nbsp;it&nbsp;is&nbsp;not&nbsp;blocked,&nbsp;increase<br>
dy&nbsp;and&nbsp;increase&nbsp;y&nbsp;by&nbsp;dy.&nbsp;When&nbsp;it&nbsp;is&nbsp;blocked,&nbsp;we&nbsp;turn<br>
around&nbsp;and&nbsp;increase&nbsp;by&nbsp;only&nbsp;half&nbsp;the&nbsp;dy,&nbsp;then&nbsp;we&nbsp;continue<br>
until&nbsp;it&nbsp;is&nbsp;unblocked,&nbsp;turn&nbsp;around,&nbsp;divide&nbsp;dy&nbsp;by&nbsp;2,&nbsp;etc...<br>
This&nbsp;rapidly&nbsp;converges&nbsp;to&nbsp;the&nbsp;position&nbsp;at&nbsp;which&nbsp;the&nbsp;ray<br>
is&nbsp;blocked,&nbsp;which&nbsp;is&nbsp;the&nbsp;field&nbsp;stop&nbsp;half&nbsp;diameter.&nbsp;This<br>
strategy&nbsp;is&nbsp;better&nbsp;than&nbsp;linearly&nbsp;going&nbsp;through&nbsp;<a href="builtins.html#object">object</a>&nbsp;heights<br>
because&nbsp;the&nbsp;precision&nbsp;can&nbsp;be&nbsp;very&nbsp;high&nbsp;without&nbsp;a&nbsp;long&nbsp;calculation<br>
time.<br>
&nbsp;<br>
It&nbsp;is&nbsp;possible&nbsp;to&nbsp;have&nbsp;finite&nbsp;diameter&nbsp;elements&nbsp;but<br>
still&nbsp;an&nbsp;infinite&nbsp;field&nbsp;of&nbsp;view&nbsp;and&nbsp;therefore&nbsp;no&nbsp;Field&nbsp;stop.<br>
In&nbsp;fact,&nbsp;if&nbsp;only&nbsp;a&nbsp;single&nbsp;element&nbsp;has&nbsp;a&nbsp;finite&nbsp;diameter,<br>
there&nbsp;is&nbsp;no&nbsp;field&nbsp;stop&nbsp;(only&nbsp;an&nbsp;aperture&nbsp;stop).&nbsp;The&nbsp;limit<br>
is&nbsp;arbitrarily&nbsp;set&nbsp;to&nbsp;maxHeight.<br>
&nbsp;<br>
If&nbsp;there&nbsp;are&nbsp;no&nbsp;elements&nbsp;of&nbsp;finite&nbsp;diameter&nbsp;(i.e.&nbsp;all<br>
optical&nbsp;elements&nbsp;are&nbsp;infinite&nbsp;in&nbsp;diameters),&nbsp;then&nbsp;there<br>
is&nbsp;no&nbsp;field&nbsp;stop&nbsp;and&nbsp;no&nbsp;aperture&nbsp;stop&nbsp;in&nbsp;the&nbsp;system<br>
and&nbsp;their&nbsp;sizes&nbsp;are&nbsp;infinite.</tt></dd></dl>

<dl><dt><a name="ImagingPath-imageSize"><strong>imageSize</strong></a>(self)</dt><dd><tt>The&nbsp;image&nbsp;size&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;field&nbsp;of&nbsp;view<br>
multiplied&nbsp;by&nbsp;magnification</tt></dd></dl>

<dl><dt><a name="ImagingPath-marginalRays"><strong>marginalRays</strong></a>(self, y=0)</dt><dd><tt>Marginal&nbsp;rays&nbsp;for&nbsp;a&nbsp;height&nbsp;y&nbsp;at&nbsp;<a href="builtins.html#object">object</a><br>
(i.e.,&nbsp;the&nbsp;rays&nbsp;that&nbsp;hit&nbsp;the&nbsp;upper&nbsp;and&nbsp;lower<br>
edges&nbsp;of&nbsp;the&nbsp;aperture&nbsp;stop).&nbsp;In&nbsp;general,&nbsp;this&nbsp;could<br>
be&nbsp;any&nbsp;height,&nbsp;not&nbsp;just&nbsp;y=0.&nbsp;However,&nbsp;we&nbsp;usually<br>
only&nbsp;want&nbsp;y=0&nbsp;which&nbsp;is&nbsp;implicitly&nbsp;called<br>
"the&nbsp;marginal&nbsp;ray&nbsp;(of&nbsp;the&nbsp;system)",&nbsp;and&nbsp;both&nbsp;rays<br>
will&nbsp;be&nbsp;symmetrically&nbsp;oriented&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the<br>
optical&nbsp;axis.<br>
&nbsp;<br>
The&nbsp;calculation&nbsp;is&nbsp;simple:&nbsp;obtain&nbsp;the&nbsp;transfer&nbsp;matrix<br>
to&nbsp;the&nbsp;aperture&nbsp;stop,&nbsp;then&nbsp;we&nbsp;know&nbsp;that&nbsp;the&nbsp;input&nbsp;ray<br>
(which&nbsp;we&nbsp;are&nbsp;looking&nbsp;for)&nbsp;will&nbsp;end&nbsp;at&nbsp;y=&nbsp;plus/minus&nbsp;diameter/2&nbsp;at&nbsp;the<br>
aperture&nbsp;stop.&nbsp;We&nbsp;return&nbsp;the&nbsp;largest&nbsp;angle&nbsp;first,&nbsp;for<br>
convenience.</tt></dd></dl>

<dl><dt><a name="ImagingPath-rearrangeRayTraceForPlotting"><strong>rearrangeRayTraceForPlotting</strong></a>(self, rayList, removeBlockedRaysCompletely=True)</dt></dl>

<dl><dt><a name="ImagingPath-save"><strong>save</strong></a>(self, filepath, limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=False, removeBlockedRaysCompletely=False, comments=None)</dt></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#MatrixGroup">MatrixGroup</a>:<br>
<dl><dt><a name="ImagingPath-ImagingPath"><strong>ImagingPath</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-LaserPath"><strong>LaserPath</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-append"><strong>append</strong></a>(self, matrix)</dt><dd><tt>Add&nbsp;an&nbsp;element&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;path</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=True)</dt><dd><tt>Draw&nbsp;each&nbsp;element&nbsp;of&nbsp;this&nbsp;group</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.<br>
&nbsp;<br>
AS&nbsp;and&nbsp;FS&nbsp;are&nbsp;drawn&nbsp;at&nbsp;110%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;<a href="#ImagingPath">ImagingPath</a>&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;of&nbsp;finite&nbsp;diameter</tt></dd></dl>

<dl><dt><a name="ImagingPath-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;finite&nbsp;diameter&nbsp;in&nbsp;all&nbsp;elements</tt></dd></dl>

<dl><dt><a name="ImagingPath-propagate"><strong>propagate</strong></a>(self, inputRay)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#OpticalPath-trace">trace</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-propagateMany"><strong>propagateMany</strong></a>(self, inputRays)</dt><dd><tt>Deprecated&nbsp;function:&nbsp;use&nbsp;<a href="#OpticalPath-traceMany">traceMany</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-trace"><strong>trace</strong></a>(self, inputRay)</dt><dd><tt>Trace&nbsp;the&nbsp;input&nbsp;ray&nbsp;from&nbsp;first&nbsp;element&nbsp;until&nbsp;after&nbsp;the&nbsp;last&nbsp;element<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;ray&nbsp;trace&nbsp;(i.e.&nbsp;[<a href="#Ray">Ray</a>()])&nbsp;starting&nbsp;with&nbsp;inputRay,&nbsp;followed&nbsp;by&nbsp;the&nbsp;ray&nbsp;after<br>
each&nbsp;element.&nbsp;If&nbsp;an&nbsp;element&nbsp;is&nbsp;composed&nbsp;of&nbsp;sub-elements,&nbsp;the&nbsp;ray&nbsp;will&nbsp;also&nbsp;be<br>
traced&nbsp;in&nbsp;several&nbsp;steps.</tt></dd></dl>

<dl><dt><a name="ImagingPath-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;them&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="ImagingPath-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;transfer&nbsp;matrix&nbsp;between&nbsp;front&nbsp;edge&nbsp;and&nbsp;distance=upTo<br>
&nbsp;<br>
If&nbsp;"upTo"&nbsp;falls&nbsp;inside&nbsp;an&nbsp;element&nbsp;of&nbsp;finite&nbsp;length,&nbsp;then&nbsp;<br>
it&nbsp;will&nbsp;request&nbsp;from&nbsp;that&nbsp;element&nbsp;a&nbsp;"partial"&nbsp;transfer&nbsp;matrix<br>
for&nbsp;a&nbsp;fraction&nbsp;of&nbsp;the&nbsp;length.&nbsp;&nbsp;It&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;or&nbsp;<br>
<a href="#MatrixGroup">MatrixGroup</a>()&nbsp;to&nbsp;define&nbsp;such&nbsp;partial&nbsp;transfer&nbsp;matrix&nbsp;when&nbsp;possible.<br>
Quite&nbsp;simply,&nbsp;<a href="#Space">Space</a>()&nbsp;defines&nbsp;a&nbsp;partial&nbsp;matrix&nbsp;as&nbsp;<a href="#Space">Space</a>(d=upTo).</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="ImagingPath-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="ImagingPath-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="ImagingPath-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="ImagingPath-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ImagingPath-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="ImagingPath-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="ImagingPath-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#OpticalPath-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="ImagingPath-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ImagingPath-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ImagingPath-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="ImagingPath-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="ImagingPath-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="ImagingPath-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="ImagingPath-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="ImagingPath-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="ImagingPath-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#OpticalPath-trace">trace</a>().</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Ray">class <strong>Ray</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Ray">Ray</a>(y=0,&nbsp;theta=0,&nbsp;z=0,&nbsp;isBlocked=False)<br>
&nbsp;<br>
A&nbsp;vector&nbsp;and&nbsp;a&nbsp;light&nbsp;ray&nbsp;as&nbsp;transformed&nbsp;by&nbsp;ABCD&nbsp;matrices<br>
&nbsp;<br>
The&nbsp;<a href="#Ray">Ray</a>()&nbsp;has&nbsp;a&nbsp;height&nbsp;(y)&nbsp;and&nbsp;an&nbsp;angle&nbsp;with&nbsp;the&nbsp;optical&nbsp;axis&nbsp;(theta).<br>
It&nbsp;also&nbsp;has&nbsp;a&nbsp;position&nbsp;(z),&nbsp;the&nbsp;diameter&nbsp;of&nbsp;the&nbsp;aperture&nbsp;at&nbsp;that&nbsp;point<br>
when&nbsp;it&nbsp;propagated&nbsp;through,&nbsp;and&nbsp;a&nbsp;marker&nbsp;if&nbsp;it&nbsp;has&nbsp;been&nbsp;blocked&nbsp;by&nbsp;the<br>
aperture.<br>
&nbsp;<br>
Simple&nbsp;static&nbsp;functions&nbsp;are&nbsp;defined&nbsp;to&nbsp;obtain&nbsp;a&nbsp;group&nbsp;of&nbsp;rays:&nbsp;fans<br>
originate&nbsp;from&nbsp;the&nbsp;same&nbsp;height&nbsp;but&nbsp;sweep&nbsp;a&nbsp;range&nbsp;of&nbsp;angles;&nbsp;fan&nbsp;groups<br>
are&nbsp;fans&nbsp;originating&nbsp;from&nbsp;different&nbsp;heights.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Ray-__init__"><strong>__init__</strong></a>(self, y=0, theta=0, z=0, isBlocked=False)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Ray-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Ray">Ray</a>())</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Ray-fan"><strong>fan</strong></a>(y, radianMin, radianMax, N)</dt><dd><tt>A&nbsp;list&nbsp;of&nbsp;rays&nbsp;spanning&nbsp;from&nbsp;radianMin&nbsp;to&nbsp;radianMax&nbsp;to&nbsp;be&nbsp;used<br>
with&nbsp;<a href="#Matrix">Matrix</a>.trace()&nbsp;or&nbsp;<a href="#Matrix">Matrix</a>.traceMany()</tt></dd></dl>

<dl><dt><a name="Ray-fanGroup"><strong>fanGroup</strong></a>(yMin, yMax, M, radianMin, radianMax, N)</dt><dd><tt>A&nbsp;list&nbsp;of&nbsp;rays&nbsp;spanning&nbsp;from&nbsp;yMin&nbsp;to&nbsp;yMax&nbsp;and&nbsp;radianMin&nbsp;to<br>
radianMax&nbsp;to&nbsp;be&nbsp;used&nbsp;with&nbsp;<a href="#Matrix">Matrix</a>.trace()&nbsp;or&nbsp;<a href="#Matrix">Matrix</a>.traceMany()</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>isNotBlocked</strong></dt>
<dd><tt>Opposite&nbsp;of&nbsp;isBlocked.&nbsp;&nbsp;Convenience&nbsp;function&nbsp;for&nbsp;readability</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Space">class <strong>Space</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Space">Space</a>(d,&nbsp;n=1,&nbsp;diameter=inf,&nbsp;label='')<br>
&nbsp;<br>
Free&nbsp;space&nbsp;of&nbsp;length&nbsp;d<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#Space">Space</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Space-__init__"><strong>__init__</strong></a>(self, d, n=1, diameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Space-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;nothing&nbsp;because&nbsp;free&nbsp;space&nbsp;is&nbsp;nothing.</tt></dd></dl>

<dl><dt><a name="Space-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>Returns&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;corresponding&nbsp;to&nbsp;a&nbsp;partial&nbsp;propagation<br>
if&nbsp;the&nbsp;requested&nbsp;distance&nbsp;is&nbsp;smaller&nbsp;than&nbsp;the&nbsp;length&nbsp;of&nbsp;this&nbsp;element</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="Space-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="Space-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="Space-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="Space-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Space-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Space-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="Space-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="Space-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.&nbsp;&nbsp;Any&nbsp;element&nbsp;may&nbsp;<br>
have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size,&nbsp;so&nbsp;this&nbsp;function&nbsp;is&nbsp;general&nbsp;for&nbsp;all&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="Space-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="Space-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="Space-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="Space-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="Space-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="Space-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Space-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#Space-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="Space-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Space-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="Space-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="Space-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="Space-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="Space-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="Space-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Space-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="Space-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="Space-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>Any&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;matrix&nbsp;(focal&nbsp;points,<br>
principal&nbsp;planes&nbsp;etc...)</tt></dd></dl>

<dl><dt><a name="Space-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="Space-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="Space-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#Space-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="Space-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ThickLens">class <strong>ThickLens</strong></a>(<a href="raytracing.abcd.html#Matrix">Matrix</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ThickLens">ThickLens</a>(n,&nbsp;R1,&nbsp;R2,&nbsp;thickness,&nbsp;diameter=inf,&nbsp;label='')<br>
&nbsp;<br>
A&nbsp;thick&nbsp;lens&nbsp;of&nbsp;first&nbsp;radius&nbsp;R1&nbsp;and&nbsp;then&nbsp;R2,&nbsp;with&nbsp;an&nbsp;index&nbsp;n<br>
and&nbsp;length&nbsp;d<br>
&nbsp;<br>
A&nbsp;biconvex&nbsp;lens&nbsp;has&nbsp;R1&nbsp;&gt;&nbsp;0&nbsp;and&nbsp;R2&nbsp;&lt;&nbsp;0.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="raytracing.abcd.html#ThickLens">ThickLens</a></dd>
<dd><a href="raytracing.abcd.html#Matrix">Matrix</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ThickLens-__init__"><strong>__init__</strong></a>(self, n, R1, R2, thickness, diameter=inf, label='')</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="ThickLens-drawAperture"><strong>drawAperture</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;aperture&nbsp;size&nbsp;for&nbsp;this&nbsp;element.<br>
The&nbsp;thick&nbsp;lens&nbsp;requires&nbsp;special&nbsp;care&nbsp;because&nbsp;the&nbsp;corners&nbsp;are&nbsp;not<br>
separated&nbsp;by&nbsp;self.<strong>L</strong>:&nbsp;the&nbsp;curvature&nbsp;makes&nbsp;the&nbsp;edges&nbsp;shorter.<br>
We&nbsp;are&nbsp;picky&nbsp;and&nbsp;draw&nbsp;it&nbsp;right.</tt></dd></dl>

<dl><dt><a name="ThickLens-drawAt"><strong>drawAt</strong></a>(self, z, axes, showLabels=False)</dt><dd><tt>Draw&nbsp;a&nbsp;faint&nbsp;blue&nbsp;box&nbsp;with&nbsp;slightly&nbsp;curved&nbsp;interfaces<br>
of&nbsp;length&nbsp;'thickness'&nbsp;starting&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
An&nbsp;arc&nbsp;would&nbsp;be&nbsp;perfect,&nbsp;but&nbsp;matplotlib&nbsp;does&nbsp;not&nbsp;allow&nbsp;to&nbsp;fill<br>
an&nbsp;arc,&nbsp;hence&nbsp;we&nbsp;must&nbsp;use&nbsp;a&nbsp;patch&nbsp;and&nbsp;Bezier&nbsp;curve.<br>
We&nbsp;might&nbsp;as&nbsp;well&nbsp;draw&nbsp;it&nbsp;properly:&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;draw&nbsp;a<br>
quadratic&nbsp;bezier&nbsp;curve&nbsp;that&nbsp;looks&nbsp;like&nbsp;an&nbsp;arc,&nbsp;see:<br>
https://pomax.github.io/bezierinfo/#circles_cubic</tt></dd></dl>

<dl><dt><a name="ThickLens-pointsOfInterest"><strong>pointsOfInterest</strong></a>(self, z)</dt><dd><tt>List&nbsp;of&nbsp;points&nbsp;of&nbsp;interest&nbsp;for&nbsp;this&nbsp;element&nbsp;as&nbsp;a&nbsp;dictionary:<br>
'z':position<br>
'label':the&nbsp;label&nbsp;to&nbsp;be&nbsp;used.&nbsp;&nbsp;Can&nbsp;include&nbsp;LaTeX&nbsp;math&nbsp;code.</tt></dd></dl>

<hr>
Methods inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><a name="ThickLens-__mul__"><strong>__mul__</strong></a>(self, rightSide)</dt><dd><tt>Operator&nbsp;overloading&nbsp;allowing&nbsp;easy&nbsp;to&nbsp;read&nbsp;matrix&nbsp;multiplication<br>
&nbsp;<br>
For&nbsp;instance,&nbsp;with&nbsp;M1&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;and&nbsp;M2&nbsp;=&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;one&nbsp;can&nbsp;write<br>
M3&nbsp;=&nbsp;M1*M2.&nbsp;With&nbsp;r&nbsp;=&nbsp;<a href="#Ray">Ray</a>(),&nbsp;one&nbsp;can&nbsp;apply&nbsp;the&nbsp;M1&nbsp;transform&nbsp;to&nbsp;a&nbsp;ray<br>
with&nbsp;r&nbsp;=&nbsp;M1*r</tt></dd></dl>

<dl><dt><a name="ThickLens-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>String&nbsp;description&nbsp;that&nbsp;allows&nbsp;the&nbsp;use&nbsp;of&nbsp;print(<a href="#Matrix">Matrix</a>())</tt></dd></dl>

<dl><dt><a name="ThickLens-axesToDataScaling"><strong>axesToDataScaling</strong></a>(self, axes)</dt><dd><tt>For&nbsp;drawing&nbsp;properly&nbsp;arrows&nbsp;and&nbsp;other&nbsp;things,&nbsp;sometimes&nbsp;<br>
we&nbsp;need&nbsp;to&nbsp;draw&nbsp;along&nbsp;y&nbsp;in&nbsp;real&nbsp;space&nbsp;but&nbsp;in&nbsp;x&nbsp;in&nbsp;relative&nbsp;space&nbsp;<br>
(i.e.&nbsp;relative&nbsp;to&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;graph,&nbsp;not&nbsp;x&nbsp;coordinates).<br>
There&nbsp;are&nbsp;transforms&nbsp;in&nbsp;matplotlib,&nbsp;but&nbsp;only&nbsp;between&nbsp;axes-display,&nbsp;<br>
and&nbsp;data-display,&nbsp;not&nbsp;between&nbsp;data-axes.&nbsp;&nbsp;Here&nbsp;we&nbsp;obtain&nbsp;the&nbsp;scaling<br>
so&nbsp;we&nbsp;can&nbsp;set&nbsp;arrow&nbsp;properties&nbsp;intelligently</tt></dd></dl>

<dl><dt><a name="ThickLens-backFocalLength"><strong>backFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;back&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertex.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ThickLens-backwardConjugate"><strong>backwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,<br>
where&nbsp;is&nbsp;the&nbsp;<a href="builtins.html#object">object</a>&nbsp;?&nbsp;Distance&nbsp;before&nbsp;the&nbsp;element&nbsp;by<br>
which&nbsp;a&nbsp;ray&nbsp;must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;at<br>
the&nbsp;back&nbsp;of&nbsp;the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the<br>
<a href="builtins.html#object">object</a>&nbsp;is&nbsp;"distance"&nbsp;in&nbsp;front&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the<br>
left,&nbsp;or&nbsp;before).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;M1*<a href="#Space">Space</a>(distance)<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ThickLens-display"><strong>display</strong></a>(self)</dt><dd><tt>Display&nbsp;this&nbsp;component,&nbsp;without&nbsp;any&nbsp;ray&nbsp;tracing&nbsp;but&nbsp;with&nbsp;<br>
all&nbsp;of&nbsp;its&nbsp;cardinal&nbsp;points&nbsp;and&nbsp;planes.&nbsp;If&nbsp;the&nbsp;component&nbsp;has&nbsp;no<br>
power&nbsp;(i.e.&nbsp;C&nbsp;==&nbsp;0)&nbsp;this&nbsp;will&nbsp;fail.</tt></dd></dl>

<dl><dt><a name="ThickLens-displayHalfHeight"><strong>displayHalfHeight</strong></a>(self)</dt><dd><tt>A&nbsp;reasonable&nbsp;height&nbsp;for&nbsp;display&nbsp;purposes&nbsp;for<br>
an&nbsp;element,&nbsp;whether&nbsp;it&nbsp;is&nbsp;infinite&nbsp;or&nbsp;not.<br>
&nbsp;<br>
If&nbsp;the&nbsp;element&nbsp;is&nbsp;infinite,&nbsp;currently&nbsp;the&nbsp;half-height<br>
will&nbsp;be&nbsp;'4'.&nbsp;If&nbsp;not,&nbsp;it&nbsp;is&nbsp;the&nbsp;apertureDiameter/2.</tt></dd></dl>

<dl><dt><a name="ThickLens-drawCardinalPoints"><strong>drawCardinalPoints</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;focal&nbsp;points&nbsp;of&nbsp;a&nbsp;thin&nbsp;lens&nbsp;as&nbsp;black&nbsp;dots</tt></dd></dl>

<dl><dt><a name="ThickLens-drawLabels"><strong>drawLabels</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;element&nbsp;labels&nbsp;on&nbsp;plot&nbsp;with&nbsp;starting&nbsp;edge&nbsp;at&nbsp;'z'.<br>
&nbsp;<br>
Labels&nbsp;are&nbsp;drawn&nbsp;50%&nbsp;above&nbsp;the&nbsp;display&nbsp;height</tt></dd></dl>

<dl><dt><a name="ThickLens-drawPointsOfInterest"><strong>drawPointsOfInterest</strong></a>(self, z, axes)</dt><dd><tt>Labels&nbsp;of&nbsp;general&nbsp;points&nbsp;of&nbsp;interest&nbsp;are&nbsp;drawn&nbsp;below&nbsp;the<br>
axis,&nbsp;at&nbsp;25%&nbsp;of&nbsp;the&nbsp;largest&nbsp;diameter.</tt></dd></dl>

<dl><dt><a name="ThickLens-drawPrincipalPlanes"><strong>drawPrincipalPlanes</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;the&nbsp;principal&nbsp;planes</tt></dd></dl>

<dl><dt><a name="ThickLens-drawVertices"><strong>drawVertices</strong></a>(self, z, axes)</dt><dd><tt>Draw&nbsp;vertices&nbsp;of&nbsp;the&nbsp;system</tt></dd></dl>

<dl><dt><a name="ThickLens-effectiveFocalLengths"><strong>effectiveFocalLengths</strong></a>(self)</dt><dd><tt>The&nbsp;effective&nbsp;focal&nbsp;lengths&nbsp;calculated&nbsp;from&nbsp;the&nbsp;power&nbsp;(C)<br>
of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;lengths&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ThickLens-focalDistances"><strong>focalDistances</strong></a>(self)</dt><dd><tt>Synonym&nbsp;of&nbsp;<a href="#ThickLens-effectiveFocalLengths">effectiveFocalLengths</a>()</tt></dd></dl>

<dl><dt><a name="ThickLens-focusPositions"><strong>focusPositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;both&nbsp;focal&nbsp;points&nbsp;on&nbsp;either&nbsp;side&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and&nbsp;both&nbsp;focal<br>
distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ThickLens-forwardConjugate"><strong>forwardConjugate</strong></a>(self)</dt><dd><tt>With&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;of&nbsp;the&nbsp;element,&nbsp;where<br>
is&nbsp;the&nbsp;image?&nbsp;Distance&nbsp;after&nbsp;the&nbsp;element&nbsp;by&nbsp;which&nbsp;a&nbsp;ray<br>
must&nbsp;travel&nbsp;to&nbsp;reach&nbsp;the&nbsp;conjugate&nbsp;plane&nbsp;of&nbsp;the&nbsp;front&nbsp;of<br>
the&nbsp;element.&nbsp;A&nbsp;positive&nbsp;distance&nbsp;means&nbsp;the&nbsp;image&nbsp;is&nbsp;"distance"<br>
beyond&nbsp;the&nbsp;back&nbsp;of&nbsp;the&nbsp;element&nbsp;(or&nbsp;to&nbsp;the&nbsp;right,&nbsp;or&nbsp;after).<br>
&nbsp;<br>
M2&nbsp;=&nbsp;<a href="#Space">Space</a>(distance)*M1<br>
#&nbsp;M2.isImaging&nbsp;==&nbsp;True</tt></dd></dl>

<dl><dt><a name="ThickLens-frontFocalLength"><strong>frontFocalLength</strong></a>(self)</dt><dd><tt>The&nbsp;focal&nbsp;lengths&nbsp;measured&nbsp;from&nbsp;the&nbsp;front&nbsp;vertex.<br>
This&nbsp;is&nbsp;the&nbsp;distance&nbsp;between&nbsp;the&nbsp;surface&nbsp;and&nbsp;the&nbsp;focal&nbsp;point.<br>
When&nbsp;the&nbsp;principal&nbsp;plane&nbsp;is&nbsp;not&nbsp;at&nbsp;the&nbsp;surface&nbsp;(which&nbsp;is&nbsp;usually<br>
the&nbsp;case&nbsp;in&nbsp;anything&nbsp;except&nbsp;a&nbsp;thin&nbsp;lens),&nbsp;the&nbsp;back&nbsp;and&nbsp;front&nbsp;focal<br>
lengths&nbsp;will&nbsp;be&nbsp;different&nbsp;from&nbsp;effective&nbsp;focal&nbsp;lengths.&nbsp;The&nbsp;effective<br>
focal&nbsp;lengths&nbsp;is&nbsp;always&nbsp;measured&nbsp;from&nbsp;the&nbsp;principal&nbsp;planes,&nbsp;but&nbsp;the<br>
BFL&nbsp;and&nbsp;FFL&nbsp;are&nbsp;measured&nbsp;from&nbsp;the&nbsp;vertices.<br>
&nbsp;<br>
If&nbsp;the&nbsp;matrix&nbsp;is&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;product&nbsp;of&nbsp;several&nbsp;matrices,<br>
we&nbsp;may&nbsp;not&nbsp;know&nbsp;where&nbsp;the&nbsp;front&nbsp;and&nbsp;back&nbsp;vertices&nbsp;are.&nbsp;In&nbsp;that&nbsp;case,<br>
we&nbsp;return&nbsp;None&nbsp;(or&nbsp;undefined).<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side&nbsp;and<br>
both&nbsp;focal&nbsp;distances&nbsp;are&nbsp;the&nbsp;same.</tt></dd></dl>

<dl><dt><a name="ThickLens-hasFiniteApertureDiameter"><strong>hasFiniteApertureDiameter</strong></a>(self)</dt><dd><tt>True&nbsp;if&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements&nbsp;have&nbsp;a&nbsp;finite&nbsp;aperture&nbsp;size</tt></dd></dl>

<dl><dt><a name="ThickLens-largestDiameter"><strong>largestDiameter</strong></a>(self)</dt><dd><tt>Largest&nbsp;diameter&nbsp;of&nbsp;the&nbsp;element&nbsp;or&nbsp;group&nbsp;of&nbsp;elements</tt></dd></dl>

<dl><dt><a name="ThickLens-magnification"><strong>magnification</strong></a>(self)</dt></dl>

<dl><dt><a name="ThickLens-mul_beam"><strong>mul_beam</strong></a>(self, rightSideBeam)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;coherent&nbsp;beam&nbsp;with&nbsp;complex&nbsp;radius<br>
of&nbsp;curvature&nbsp;q&nbsp;by&nbsp;a&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="ThickLens-mul_matrix"><strong>mul_matrix</strong></a>(self, rightSideMatrix)</dt><dd><tt>Multiplication&nbsp;of&nbsp;two&nbsp;matrices.&nbsp;&nbsp;Total&nbsp;length&nbsp;of&nbsp;the<br>
elements&nbsp;is&nbsp;calculated.&nbsp;Apertures&nbsp;are&nbsp;lost.&nbsp;We&nbsp;compute<br>
the&nbsp;first&nbsp;and&nbsp;last&nbsp;vertices.</tt></dd></dl>

<dl><dt><a name="ThickLens-mul_ray"><strong>mul_ray</strong></a>(self, rightSideRay)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;ray&nbsp;by&nbsp;a&nbsp;matrix.&nbsp;&nbsp;New&nbsp;position&nbsp;of<br>
ray&nbsp;is&nbsp;updated&nbsp;by&nbsp;the&nbsp;physical&nbsp;length&nbsp;of&nbsp;the&nbsp;matrix.<br>
If&nbsp;the&nbsp;ray&nbsp;is&nbsp;beyond&nbsp;the&nbsp;aperture&nbsp;diameter&nbsp;it&nbsp;is&nbsp;labelled<br>
as&nbsp;"isBlocked&nbsp;=&nbsp;True"&nbsp;but&nbsp;can&nbsp;still&nbsp;propagate.</tt></dd></dl>

<dl><dt><a name="ThickLens-principalPlanePositions"><strong>principalPlanePositions</strong></a>(self, z)</dt><dd><tt>Positions&nbsp;of&nbsp;the&nbsp;input&nbsp;and&nbsp;output&nbsp;principal&nbsp;planes.<br>
&nbsp;<br>
Currently,&nbsp;it&nbsp;is&nbsp;assumed&nbsp;the&nbsp;index&nbsp;is&nbsp;n=1&nbsp;on&nbsp;either&nbsp;side.</tt></dd></dl>

<dl><dt><a name="ThickLens-trace"><strong>trace</strong></a>(self, ray)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;rays&nbsp;(i.e.&nbsp;a&nbsp;ray&nbsp;trace)&nbsp;for&nbsp;the&nbsp;input&nbsp;ray&nbsp;through&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Because&nbsp;we&nbsp;want&nbsp;to&nbsp;manage&nbsp;blockage&nbsp;by&nbsp;apertures,&nbsp;we&nbsp;need&nbsp;to&nbsp;perform&nbsp;a&nbsp;two-step&nbsp;process<br>
for&nbsp;elements&nbsp;that&nbsp;have&nbsp;a&nbsp;finite,&nbsp;non-null&nbsp;length:&nbsp;where&nbsp;is&nbsp;the&nbsp;ray&nbsp;blocked&nbsp;exactly?<br>
It&nbsp;can&nbsp;be&nbsp;blocked&nbsp;at&nbsp;the&nbsp;entrance,&nbsp;at&nbsp;the&nbsp;exit,&nbsp;or&nbsp;anywhere&nbsp;in&nbsp;between.<br>
The&nbsp;aperture&nbsp;diameter&nbsp;for&nbsp;a&nbsp;finite-length&nbsp;element&nbsp;is&nbsp;constant&nbsp;across&nbsp;the&nbsp;length<br>
of&nbsp;the&nbsp;element.&nbsp;We&nbsp;therefore&nbsp;check&nbsp;before&nbsp;entering&nbsp;the&nbsp;element&nbsp;and&nbsp;after&nbsp;having<br>
propagated&nbsp;through&nbsp;the&nbsp;element.&nbsp;For&nbsp;now,&nbsp;this&nbsp;will&nbsp;suffice.<br>
If&nbsp;the&nbsp;length&nbsp;is&nbsp;null,&nbsp;the&nbsp;ray&nbsp;is&nbsp;traced&nbsp;in&nbsp;a&nbsp;single&nbsp;step</tt></dd></dl>

<dl><dt><a name="ThickLens-traceMany"><strong>traceMany</strong></a>(self, inputRays)</dt><dd><tt>Trace&nbsp;each&nbsp;ray&nbsp;from&nbsp;a&nbsp;list&nbsp;from&nbsp;front&nbsp;edge&nbsp;of&nbsp;element&nbsp;to<br>
the&nbsp;back&nbsp;edge.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;ray&nbsp;traces&nbsp;for&nbsp;each&nbsp;input&nbsp;ray.<br>
See&nbsp;<a href="#ThickLens-trace">trace</a>().</tt></dd></dl>

<dl><dt><a name="ThickLens-transferMatrices"><strong>transferMatrices</strong></a>(self)</dt><dd><tt>The&nbsp;list&nbsp;of&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;propagation&nbsp;through&nbsp;<br>
this&nbsp;element&nbsp;(or&nbsp;group).&nbsp;For&nbsp;a&nbsp;<a href="#Matrix">Matrix</a>(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;a&nbsp;list&nbsp;<br>
with&nbsp;a&nbsp;single&nbsp;element&nbsp;[self].<br>
For&nbsp;a&nbsp;<a href="#MatrixGroup">MatrixGroup</a>(),&nbsp;it&nbsp;returns&nbsp;the&nbsp;transferMatrices&nbsp;for&nbsp;<br>
each&nbsp;individual&nbsp;element&nbsp;and&nbsp;appends&nbsp;each&nbsp;element&nbsp;to&nbsp;a&nbsp;list&nbsp;for&nbsp;this&nbsp;group.</tt></dd></dl>

<dl><dt><a name="ThickLens-transferMatrix"><strong>transferMatrix</strong></a>(self, upTo=inf)</dt><dd><tt>The&nbsp;<a href="#Matrix">Matrix</a>()&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;propagation&nbsp;from&nbsp;the&nbsp;edge<br>
of&nbsp;the&nbsp;element&nbsp;(z=0)&nbsp;up&nbsp;to&nbsp;distance&nbsp;"upTo"&nbsp;(z=upTo).&nbsp;If&nbsp;no&nbsp;parameter&nbsp;is&nbsp;<br>
provided,&nbsp;the&nbsp;transfer&nbsp;matrix&nbsp;will&nbsp;be&nbsp;from&nbsp;the&nbsp;front&nbsp;edge&nbsp;to&nbsp;the&nbsp;back&nbsp;edge.<br>
If&nbsp;the&nbsp;element&nbsp;has&nbsp;a&nbsp;null&nbsp;thickness,&nbsp;the&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;element<br>
is&nbsp;returned.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>determinant</strong></dt>
</dl>
<dl><dt><strong>hasPower</strong></dt>
</dl>
<dl><dt><strong>isImaging</strong></dt>
<dd><tt>If&nbsp;B=0,&nbsp;then&nbsp;the&nbsp;matrix&nbsp;is&nbsp;from&nbsp;a&nbsp;conjugate&nbsp;plane&nbsp;to&nbsp;another<br>
(i.e.&nbsp;object&nbsp;at&nbsp;the&nbsp;front&nbsp;edge&nbsp;and&nbsp;image&nbsp;at&nbsp;the&nbsp;back&nbsp;edge).<br>
&nbsp;<br>
In&nbsp;this&nbsp;case,&nbsp;A&nbsp;=&nbsp;transverse&nbsp;magnification,&nbsp;D&nbsp;=&nbsp;angular&nbsp;magnification<br>
As&nbsp;usual,&nbsp;C&nbsp;=&nbsp;-1/f&nbsp;(always).</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="raytracing.abcd.html#Matrix">Matrix</a>:<br>
<dl><dt><strong>__epsilon__</strong> = 1e-05</dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>degPerRad</strong> = 57.29577951308232<br>
<strong>radPerDeg</strong> = 0.017453292519943295</td></tr></table>
</body></html>